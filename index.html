<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>JavaScript Session Establishment Protocol</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 General Design of JSEP">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Other Approaches Considered">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Semantics and Syntax">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Signaling Model">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Session Descriptions and State Machine">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Session Description Format">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Session Description Control">
<link href="#rfc.section.3.4.1" rel="Chapter" title="3.4.1 RtpTransceivers">
<link href="#rfc.section.3.4.2" rel="Chapter" title="3.4.2 RtpSenders">
<link href="#rfc.section.3.4.3" rel="Chapter" title="3.4.3 RtpReceivers">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 ICE">
<link href="#rfc.section.3.5.1" rel="Chapter" title="3.5.1 ICE Gathering Overview">
<link href="#rfc.section.3.5.2" rel="Chapter" title="3.5.2 ICE Candidate Trickling">
<link href="#rfc.section.3.5.2.1" rel="Chapter" title="3.5.2.1 ICE Candidate Format">
<link href="#rfc.section.3.5.3" rel="Chapter" title="3.5.3 ICE Candidate Policy">
<link href="#rfc.section.3.5.4" rel="Chapter" title="3.5.4 ICE Candidate Pool">
<link href="#rfc.section.3.5.5" rel="Chapter" title="3.5.5 ICE Versions">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 Video Size Negotiation">
<link href="#rfc.section.3.6.1" rel="Chapter" title="3.6.1 Creating an imageattr Attribute">
<link href="#rfc.section.3.6.2" rel="Chapter" title="3.6.2 Interpreting imageattr Attributes">
<link href="#rfc.section.3.7" rel="Chapter" title="3.7 Simulcast">
<link href="#rfc.section.3.8" rel="Chapter" title="3.8 Interactions With Forking">
<link href="#rfc.section.3.8.1" rel="Chapter" title="3.8.1 Sequential Forking">
<link href="#rfc.section.3.8.2" rel="Chapter" title="3.8.2 Parallel Forking">
<link href="#rfc.section.4" rel="Chapter" title="4 Interface">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 PeerConnection">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Constructor">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 addTrack">
<link href="#rfc.section.4.1.3" rel="Chapter" title="4.1.3 removeTrack">
<link href="#rfc.section.4.1.4" rel="Chapter" title="4.1.4 addTransceiver">
<link href="#rfc.section.4.1.5" rel="Chapter" title="4.1.5 createDataChannel">
<link href="#rfc.section.4.1.6" rel="Chapter" title="4.1.6 createOffer">
<link href="#rfc.section.4.1.7" rel="Chapter" title="4.1.7 createAnswer">
<link href="#rfc.section.4.1.8" rel="Chapter" title="4.1.8 SessionDescriptionType">
<link href="#rfc.section.4.1.8.1" rel="Chapter" title="4.1.8.1 Use of Provisional Answers">
<link href="#rfc.section.4.1.8.2" rel="Chapter" title="4.1.8.2 Rollback">
<link href="#rfc.section.4.1.9" rel="Chapter" title="4.1.9 setLocalDescription">
<link href="#rfc.section.4.1.10" rel="Chapter" title="4.1.10 setRemoteDescription">
<link href="#rfc.section.4.1.11" rel="Chapter" title="4.1.11 currentLocalDescription">
<link href="#rfc.section.4.1.12" rel="Chapter" title="4.1.12 pendingLocalDescription">
<link href="#rfc.section.4.1.13" rel="Chapter" title="4.1.13 currentRemoteDescription">
<link href="#rfc.section.4.1.14" rel="Chapter" title="4.1.14 pendingRemoteDescription">
<link href="#rfc.section.4.1.15" rel="Chapter" title="4.1.15 canTrickleIceCandidates">
<link href="#rfc.section.4.1.16" rel="Chapter" title="4.1.16 setConfiguration">
<link href="#rfc.section.4.1.17" rel="Chapter" title="4.1.17 addIceCandidate">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 RtpTransceiver">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 stop">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 stopped">
<link href="#rfc.section.4.2.3" rel="Chapter" title="4.2.3 setDirection">
<link href="#rfc.section.4.2.4" rel="Chapter" title="4.2.4 direction">
<link href="#rfc.section.4.2.5" rel="Chapter" title="4.2.5 currentDirection">
<link href="#rfc.section.4.2.6" rel="Chapter" title="4.2.6 setCodecPreferences">
<link href="#rfc.section.5" rel="Chapter" title="5 SDP Interaction Procedures">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Requirements Overview">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Usage Requirements">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Profile Names and Interoperability">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Constructing an Offer">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Initial Offers">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Subsequent Offers">
<link href="#rfc.section.5.2.3" rel="Chapter" title="5.2.3 Options Handling">
<link href="#rfc.section.5.2.3.1" rel="Chapter" title="5.2.3.1 IceRestart">
<link href="#rfc.section.5.2.3.2" rel="Chapter" title="5.2.3.2 VoiceActivityDetection">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Generating an Answer">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Initial Answers">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Subsequent Answers">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Options Handling">
<link href="#rfc.section.5.3.3.1" rel="Chapter" title="5.3.3.1 VoiceActivityDetection">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Modifying an Offer or Answer">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Processing a Local Description">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Processing a Remote Description">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Processing a Rollback">
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Parsing a Session Description">
<link href="#rfc.section.5.8.1" rel="Chapter" title="5.8.1 Session-Level Parsing">
<link href="#rfc.section.5.8.2" rel="Chapter" title="5.8.2 Media Section Parsing">
<link href="#rfc.section.5.8.3" rel="Chapter" title="5.8.3 Semantics Verification">
<link href="#rfc.section.5.9" rel="Chapter" title="5.9 Applying a Local Description">
<link href="#rfc.section.5.10" rel="Chapter" title="5.10 Applying a Remote Description">
<link href="#rfc.section.5.11" rel="Chapter" title="5.11 Applying an Answer">
<link href="#rfc.section.6" rel="Chapter" title="6 Processing RTP/RTCP">
<link href="#rfc.section.7" rel="Chapter" title="7 Examples">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Simple Example">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Detailed Example">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Early Transport Warmup Example">
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="11 References">
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Appendix A">
<link href="#rfc.appendix.B" rel="Chapter" title="B Change log">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.20.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Uberti, J., Jennings, C., and E. Rescorla, Ed." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-rtcweb-jsep-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-28" />
  <meta name="dct.abstract" content="This document describes the mechanisms for allowing a JavaScript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols." />
  <meta name="description" content="This document describes the mechanisms for allowing a JavaScript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">J. Uberti</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">C. Jennings</td>
</tr>
<tr>
<td class="left">Expires: September 1, 2019</td>
<td class="right">Cisco</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">E. Rescorla, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Mozilla</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">February 28, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">JavaScript Session Establishment Protocol<br />
  <span class="filename">draft-ietf-rtcweb-jsep-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document describes the mechanisms for allowing a JavaScript application to control the signaling plane of a multimedia session via the interface specified in the W3C RTCPeerConnection API, and discusses how this relates to existing signaling protocols.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 1, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">General Design of JSEP</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Other Approaches Considered</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Semantics and Syntax</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Signaling Model</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Session Descriptions and State Machine</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Session Description Format</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">Session Description Control</a>
</li>
<ul><li>3.4.1.   <a href="#rfc.section.3.4.1">RtpTransceivers</a>
</li>
<li>3.4.2.   <a href="#rfc.section.3.4.2">RtpSenders</a>
</li>
<li>3.4.3.   <a href="#rfc.section.3.4.3">RtpReceivers</a>
</li>
</ul><li>3.5.   <a href="#rfc.section.3.5">ICE</a>
</li>
<ul><li>3.5.1.   <a href="#rfc.section.3.5.1">ICE Gathering Overview</a>
</li>
<li>3.5.2.   <a href="#rfc.section.3.5.2">ICE Candidate Trickling</a>
</li>
<ul><li>3.5.2.1.   <a href="#rfc.section.3.5.2.1">ICE Candidate Format</a>
</li>
</ul><li>3.5.3.   <a href="#rfc.section.3.5.3">ICE Candidate Policy</a>
</li>
<li>3.5.4.   <a href="#rfc.section.3.5.4">ICE Candidate Pool</a>
</li>
<li>3.5.5.   <a href="#rfc.section.3.5.5">ICE Versions</a>
</li>
</ul><li>3.6.   <a href="#rfc.section.3.6">Video Size Negotiation</a>
</li>
<ul><li>3.6.1.   <a href="#rfc.section.3.6.1">Creating an imageattr Attribute</a>
</li>
<li>3.6.2.   <a href="#rfc.section.3.6.2">Interpreting imageattr Attributes</a>
</li>
</ul><li>3.7.   <a href="#rfc.section.3.7">Simulcast</a>
</li>
<li>3.8.   <a href="#rfc.section.3.8">Interactions With Forking</a>
</li>
<ul><li>3.8.1.   <a href="#rfc.section.3.8.1">Sequential Forking</a>
</li>
<li>3.8.2.   <a href="#rfc.section.3.8.2">Parallel Forking</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Interface</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">PeerConnection</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Constructor</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">addTrack</a>
</li>
<li>4.1.3.   <a href="#rfc.section.4.1.3">removeTrack</a>
</li>
<li>4.1.4.   <a href="#rfc.section.4.1.4">addTransceiver</a>
</li>
<li>4.1.5.   <a href="#rfc.section.4.1.5">createDataChannel</a>
</li>
<li>4.1.6.   <a href="#rfc.section.4.1.6">createOffer</a>
</li>
<li>4.1.7.   <a href="#rfc.section.4.1.7">createAnswer</a>
</li>
<li>4.1.8.   <a href="#rfc.section.4.1.8">SessionDescriptionType</a>
</li>
<ul><li>4.1.8.1.   <a href="#rfc.section.4.1.8.1">Use of Provisional Answers</a>
</li>
<li>4.1.8.2.   <a href="#rfc.section.4.1.8.2">Rollback</a>
</li>
</ul><li>4.1.9.   <a href="#rfc.section.4.1.9">setLocalDescription</a>
</li>
<li>4.1.10.   <a href="#rfc.section.4.1.10">setRemoteDescription</a>
</li>
<li>4.1.11.   <a href="#rfc.section.4.1.11">currentLocalDescription</a>
</li>
<li>4.1.12.   <a href="#rfc.section.4.1.12">pendingLocalDescription</a>
</li>
<li>4.1.13.   <a href="#rfc.section.4.1.13">currentRemoteDescription</a>
</li>
<li>4.1.14.   <a href="#rfc.section.4.1.14">pendingRemoteDescription</a>
</li>
<li>4.1.15.   <a href="#rfc.section.4.1.15">canTrickleIceCandidates</a>
</li>
<li>4.1.16.   <a href="#rfc.section.4.1.16">setConfiguration</a>
</li>
<li>4.1.17.   <a href="#rfc.section.4.1.17">addIceCandidate</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">RtpTransceiver</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">stop</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">stopped</a>
</li>
<li>4.2.3.   <a href="#rfc.section.4.2.3">setDirection</a>
</li>
<li>4.2.4.   <a href="#rfc.section.4.2.4">direction</a>
</li>
<li>4.2.5.   <a href="#rfc.section.4.2.5">currentDirection</a>
</li>
<li>4.2.6.   <a href="#rfc.section.4.2.6">setCodecPreferences</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">SDP Interaction Procedures</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Requirements Overview</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Usage Requirements</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Profile Names and Interoperability</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Constructing an Offer</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Initial Offers</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Subsequent Offers</a>
</li>
<li>5.2.3.   <a href="#rfc.section.5.2.3">Options Handling</a>
</li>
<ul><li>5.2.3.1.   <a href="#rfc.section.5.2.3.1">IceRestart</a>
</li>
<li>5.2.3.2.   <a href="#rfc.section.5.2.3.2">VoiceActivityDetection</a>
</li>
</ul></ul><li>5.3.   <a href="#rfc.section.5.3">Generating an Answer</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Initial Answers</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Subsequent Answers</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Options Handling</a>
</li>
<ul><li>5.3.3.1.   <a href="#rfc.section.5.3.3.1">VoiceActivityDetection</a>
</li>
</ul></ul><li>5.4.   <a href="#rfc.section.5.4">Modifying an Offer or Answer</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Processing a Local Description</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">Processing a Remote Description</a>
</li>
<li>5.7.   <a href="#rfc.section.5.7">Processing a Rollback</a>
</li>
<li>5.8.   <a href="#rfc.section.5.8">Parsing a Session Description</a>
</li>
<ul><li>5.8.1.   <a href="#rfc.section.5.8.1">Session-Level Parsing</a>
</li>
<li>5.8.2.   <a href="#rfc.section.5.8.2">Media Section Parsing</a>
</li>
<li>5.8.3.   <a href="#rfc.section.5.8.3">Semantics Verification</a>
</li>
</ul><li>5.9.   <a href="#rfc.section.5.9">Applying a Local Description</a>
</li>
<li>5.10.   <a href="#rfc.section.5.10">Applying a Remote Description</a>
</li>
<li>5.11.   <a href="#rfc.section.5.11">Applying an Answer</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Processing RTP/RTCP</a>
</li>
<li>7.   <a href="#rfc.section.7">Examples</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Simple Example</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Detailed Example</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Early Transport Warmup Example</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.references">References</a>
</li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Appendix A</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Change log</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#sec.introduction" id="sec.introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This document describes how the W3C WEBRTC RTCPeerConnection interface <a href="#W3C.webrtc" class="xref">[W3C.webrtc]</a> is used to control the setup, management and teardown of a multimedia session.</p>
<h2 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#sec.general-design-of-jsep" id="sec.general-design-of-jsep">General Design of JSEP</a>
</h2>
<p id="rfc.section.1.1.p.1">WebRTC call setup has been designed to focus on controlling the media plane, leaving signaling plane behavior up to the application as much as possible. The rationale is that different applications may prefer to use different protocols, such as the existing SIP call signaling protocol, or something custom to the particular application, perhaps for a novel use case. In this approach, the key information that needs to be exchanged is the multimedia session description, which specifies the necessary transport and media configuration information necessary to establish the media plane.</p>
<p id="rfc.section.1.1.p.2">With these considerations in mind, this document describes the JavaScript Session Establishment Protocol (JSEP) that allows for full control of the signaling state machine from JavaScript. As described above, JSEP assumes a model in which a JavaScript application executes inside a runtime containing WebRTC APIs (the "JSEP implementation"). The JSEP implementation is almost entirely divorced from the core signaling flow, which is instead handled by the JavaScript making use of two interfaces: (1) passing in local and remote session descriptions and (2) interacting with the ICE state machine. The combination of the JSEP implementation and the JavaScript application is referred to throughout this document as a "JSEP endpoint".</p>
<p id="rfc.section.1.1.p.3">In this document, the use of JSEP is described as if it always occurs between two JSEP endpoints. Note though in many cases it will actually be between a JSEP endpoint and some kind of server, such as a gateway or MCU. This distinction is invisible to the JSEP endpoint; it just follows the instructions it is given via the API.</p>
<p id="rfc.section.1.1.p.4">JSEP's handling of session descriptions is simple and straightforward. Whenever an offer/answer exchange is needed, the initiating side creates an offer by calling a createOffer() API. The application then uses that offer to set up its local config via the setLocalDescription() API. The offer is finally sent off to the remote side over its preferred signaling mechanism (e.g., WebSockets); upon receipt of that offer, the remote party installs it using the setRemoteDescription() API.</p>
<p id="rfc.section.1.1.p.5">To complete the offer/answer exchange, the remote party uses the createAnswer() API to generate an appropriate answer, applies it using the setLocalDescription() API, and sends the answer back to the initiator over the signaling channel. When the initiator gets that answer, it installs it using the setRemoteDescription() API, and initial setup is complete. This process can be repeated for additional offer/answer exchanges.</p>
<p id="rfc.section.1.1.p.6">Regarding ICE <a href="#RFC8445" class="xref">[RFC8445]</a>, JSEP decouples the ICE state machine from the overall signaling state machine, as the ICE state machine must remain in the JSEP implementation, because only the implementation has the necessary knowledge of candidates and other transport information. Performing this separation provides additional flexibility in protocols that decouple session descriptions from transport. For instance, in traditional SIP, each offer or answer is self-contained, including both the session descriptions and the transport information. However, <a href="#I-D.ietf-mmusic-trickle-ice-sip" class="xref">[I-D.ietf-mmusic-trickle-ice-sip]</a> allows SIP to be used with trickle ICE <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, in which the session description can be sent immediately and the transport information can be sent when available. Sending transport information separately can allow for faster ICE and DTLS startup, since ICE checks can start as soon as any transport information is available rather than waiting for all of it.  JSEP's decoupling of the ICE and signaling state machines allows it to accommodate either model.</p>
<p id="rfc.section.1.1.p.7">Through its abstraction of signaling, the JSEP approach does require the application to be aware of the signaling process.  While the application does not need to understand the contents of session descriptions to set up a call, the application must call the right APIs at the right times, convert the session descriptions and ICE information into the defined messages of its chosen signaling protocol, and perform the reverse conversion on the messages it receives from the other side.</p>
<p id="rfc.section.1.1.p.8">One way to make life easier for the application is to provide a JavaScript library that hides this complexity from the developer; said library would implement a given signaling protocol along with its state machine and serialization code, presenting a higher level call-oriented interface to the application developer. For example, libraries exist to adapt the JSEP API into an API suitable for a SIP or XMPP. Thus, JSEP provides greater control for the experienced developer without forcing any additional complexity on the novice developer.</p>
<h2 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#sec.other-approaches-consider" id="sec.other-approaches-consider">Other Approaches Considered</a>
</h2>
<p id="rfc.section.1.2.p.1">One approach that was considered instead of JSEP was to include a lightweight signaling protocol. Instead of providing session descriptions to the API, the API would produce and consume messages from this protocol. While providing a more high-level API, this put more control of signaling within the JSEP implementation, forcing it to have to understand and handle concepts like signaling glare (see <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 4).</p>
<p id="rfc.section.1.2.p.2">A second approach that was considered but not chosen was to decouple the management of the media control objects from session descriptions, instead offering APIs that would control each component directly. This was rejected based on the argument that requiring exposure of this level of complexity to the application programmer would not be beneficial; it would result in an API where even a simple example would require a significant amount of code to orchestrate all the needed interactions, as well as creating a large API surface that needed to be agreed upon and documented. In addition, these API points could be called in any order, resulting in a more complex set of interactions with the media subsystem than the JSEP approach, which specifies how session descriptions are to be evaluated and applied.</p>
<p id="rfc.section.1.2.p.3">One variation on JSEP that was considered was to keep the basic session description-oriented API, but to move the mechanism for generating offers and answers out of the JSEP implementation. Instead of providing createOffer/createAnswer methods within the implementation, this approach would instead expose a getCapabilities API which would provide the application with the information it needed in order to generate its own session descriptions. This increases the amount of work that the application needs to do; it needs to know how to generate session descriptions from capabilities, and especially how to generate the correct answer from an arbitrary offer and the supported capabilities. While this could certainly be addressed by using a library like the one mentioned above, it basically forces the use of said library even for a simple example. Providing createOffer/createAnswer avoids this problem.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#sec.terminology" id="sec.terminology">Terminology</a>
</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#sec.semantics-and-syntax" id="sec.semantics-and-syntax">Semantics and Syntax</a>
</h1>
<h2 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#sec.signaling-model" id="sec.signaling-model">Signaling Model</a>
</h2>
<p id="rfc.section.3.1.p.1">JSEP does not specify a particular signaling model or state machine, other than the generic need to exchange session descriptions in the fashion described by <a href="#RFC3264" class="xref">[RFC3264]</a> (offer/answer) in order for both sides of the session to know how to conduct the session. JSEP provides mechanisms to create offers and answers, as well as to apply them to a session. However, the JSEP implementation is totally decoupled from the actual mechanism by which these offers and answers are communicated to the remote side, including addressing, retransmission, forking, and glare handling. These issues are left entirely up to the application; the application has complete control over which offers and answers get handed to the implementation, and when.</p>
<div id="rfc.figure.1"></div>
<div id="fig-sigModel"></div>
<pre>
            
    +-----------+                               +-----------+
    |  Web App  |&lt;--- App-Specific Signaling --&gt;|  Web App  |
    +-----------+                               +-----------+
          ^                                            ^
          |  SDP                                       |  SDP
          V                                            V
    +-----------+                                +-----------+
    |   JSEP    |&lt;----------- Media ------------&gt;|   JSEP    |
    |   Impl.   |                                |   Impl.   |
    +-----------+                                +-----------+

</pre>
<p class="figure">Figure 1: JSEP Signaling Model</p>
<h2 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#sec.session-descriptions-and-state-machine" id="sec.session-descriptions-and-state-machine">Session Descriptions and State Machine</a>
</h2>
<p id="rfc.section.3.2.p.1">In order to establish the media plane, the JSEP implementation needs specific parameters to indicate what to transmit to the remote side, as well as how to handle the media that is received. These parameters are determined by the exchange of session descriptions in offers and answers, and there are certain details to this process that must be handled in the JSEP APIs.</p>
<p id="rfc.section.3.2.p.2">Whether a session description applies to the local side or the remote side affects the meaning of that description. For example, the list of codecs sent to a remote party indicates what the local side is willing to receive, which, when intersected with the set of codecs the remote side supports, specifies what the remote side should send. However, not all parameters follow this rule; some parameters are declarative and the remote side MUST either accept them or reject them altogether. An example of such a parameter is the DTLS fingerprints <a href="#RFC8122" class="xref">[RFC8122]</a>, which are calculated based on the local certificate(s) offered, and are not subject to negotiation.</p>
<p id="rfc.section.3.2.p.3">In addition, various RFCs put different conditions on the format of offers versus answers. For example, an offer may propose an arbitrary number of m= sections (i.e., media descriptions as described in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.14), but an answer must contain the exact same number as the offer.</p>
<p id="rfc.section.3.2.p.4">Lastly, while the exact media parameters are only known only after an offer and an answer have been exchanged, the offerer may receive ICE checks, and possibly media (e.g., in the case of a re-offer after a connection has been established) before it receives an answer. To properly process incoming media in this case, the offerer's media handler must be aware of the details of the offer before the answer arrives.</p>
<p id="rfc.section.3.2.p.5">Therefore, in order to handle session descriptions properly, the JSEP implementation needs: </p>

<ol>
<li>To know if a session description pertains to the local or remote side.</li>
<li>To know if a session description is an offer or an answer.</li>
<li>To allow the offer to be specified independently of the answer.</li>
</ol>

<p>JSEP addresses this by adding both setLocalDescription and setRemoteDescription methods and having session description objects contain a type field indicating the type of session description being supplied. This satisfies the requirements listed above for both the offerer, who first calls setLocalDescription(sdp [offer]) and then later setRemoteDescription(sdp [answer]), as well as for the answerer, who first calls setRemoteDescription(sdp [offer]) and then later setLocalDescription(sdp [answer]).</p>
<p id="rfc.section.3.2.p.6">During the offer/answer exchange, the outstanding offer is considered to be "pending" at the offerer and the answerer, as it may either be accepted or rejected. If this is a re-offer, each side will also have "current" local and remote descriptions, which reflect the result of the last offer/answer exchange. Sections <a href="#sec.pendinglocaldescription" class="xref">Section 4.1.12</a>, <a href="#sec.pendingremotedescription" class="xref">Section 4.1.14</a>, <a href="#sec.currentlocaldescription" class="xref">Section 4.1.11</a>, and <a href="#sec.currentremotedescription" class="xref">Section 4.1.13</a>, provide more detail on pending and current descriptions.</p>
<p id="rfc.section.3.2.p.7">JSEP also allows for an answer to be treated as provisional by the application. Provisional answers provide a way for an answerer to communicate initial session parameters back to the offerer, in order to allow the session to begin, while allowing a final answer to be specified later. This concept of a final answer is important to the offer/answer model; when such an answer is received, any extra resources allocated by the caller can be released, now that the exact session configuration is known. These "resources" can include things like extra ICE components, TURN candidates, or video decoders. Provisional answers, on the other hand, do no such deallocation; as a result, multiple dissimilar provisional answers, with their own codec choices, transport parameters, etc., can be received and applied during call setup. Note that the final answer itself may be different than any received provisional answers.</p>
<p id="rfc.section.3.2.p.8">In <a href="#RFC3264" class="xref">[RFC3264]</a>, the constraint at the signaling level is that only one offer can be outstanding for a given session, but at the media stack level, a new offer can be generated at any point. For example, when using SIP for signaling, if one offer is sent, then cancelled using a SIP CANCEL, another offer can be generated even though no answer was received for the first offer. To support this, the JSEP media layer can provide an offer via the createOffer() method whenever the JavaScript application needs one for the signaling. The answerer can send back zero or more provisional answers, and finally end the offer-answer exchange by sending a final answer. The state machine for this is as follows:</p>
<div id="rfc.figure.2"></div>
<div id="fig-state-machine"></div>
<pre>
              
                    setRemote(OFFER)               setLocal(PRANSWER)
                        /-----\                               /-----\
                        |     |                               |     |
                        v     |                               v     |
         +---------------+    |                +---------------+    |
         |               |----/                |               |----/
         |  have-        | setLocal(PRANSWER)  | have-         |
         |  remote-offer |------------------- &gt;| local-pranswer|
         |               |                     |               |
         |               |                     |               |
         +---------------+                     +---------------+
              ^   |                                   |
              |   | setLocal(ANSWER)                  |
setRemote(OFFER)  |                                   |
              |   V                  setLocal(ANSWER) |
         +---------------+                            |
         |               |                            |
         |               |&lt;---------------------------+
         |    stable     |
         |               |&lt;---------------------------+
         |               |                            |
         +---------------+          setRemote(ANSWER) |
              ^   |                                   |
              |   | setLocal(OFFER)                   |
setRemote(ANSWER) |                                   |
              |   V                                   |
         +---------------+                     +---------------+
         |               |                     |               |
         |  have-        | setRemote(PRANSWER) |have-          |
         |  local-offer  |------------------- &gt;|remote-pranswer|
         |               |                     |               |
         |               |----\                |               |----\
         +---------------+    |                +---------------+    |
                        ^     |                               ^     |
                        |     |                               |     |
                        \-----/                               \-----/
                    setLocal(OFFER)               setRemote(PRANSWER)

</pre>
<p class="figure">Figure 2: JSEP State Machine</p>
<p></p>
<p id="rfc.section.3.2.p.10">Aside from these state transitions there is no other difference between the handling of provisional ("pranswer") and final ("answer") answers.</p>
<h2 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#sec.session-description-forma" id="sec.session-description-forma">Session Description Format</a>
</h2>
<p id="rfc.section.3.3.p.1">JSEP's session descriptions use SDP syntax for their internal representation. While this format is not optimal for manipulation from JavaScript, it is widely accepted, and frequently updated with new features; any alternate encoding of session descriptions would have to keep pace with the changes to SDP, at least until the time that this new encoding eclipsed SDP in popularity.</p>
<p id="rfc.section.3.3.p.2">However, to provide for future flexibility, the SDP syntax is encapsulated within a SessionDescription object, which can be constructed from SDP, and be serialized out to SDP. If future specifications agree on a JSON format for session descriptions, we could easily enable this object to generate and consume that JSON.</p>
<p id="rfc.section.3.3.p.3">As detailed below, most applications should be able to treat the SessionDescriptions produced and consumed by these various API calls as opaque blobs; that is, the application will not need to read or change them.</p>
<h2 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#sec.session-description-ctrl" id="sec.session-description-ctrl">Session Description Control</a>
</h2>
<p id="rfc.section.3.4.p.1">In order to give the application control over various common session parameters, JSEP provides control surfaces which tell the JSEP implementation how to generate session descriptions.  This avoids the need for JavaScript to modify session descriptions in most cases.</p>
<p id="rfc.section.3.4.p.2">Changes to these objects result in changes to the session descriptions generated by subsequent createOffer/Answer calls.</p>
<h3 id="rfc.section.3.4.1">
<a href="#rfc.section.3.4.1">3.4.1.</a> <a href="#sec.rtptransceivers" id="sec.rtptransceivers">RtpTransceivers</a>
</h3>
<p id="rfc.section.3.4.1.p.1">RtpTransceivers allow the application to control the RTP media associated with one m= section. Each RtpTransceiver has an RtpSender and an RtpReceiver, which an application can use to control the sending and receiving of RTP media. The application may also modify the RtpTransceiver directly, for instance, by stopping it.</p>
<p id="rfc.section.3.4.1.p.2">RtpTransceivers generally have a 1:1 mapping with m= sections, although there may be more RtpTransceivers than m= sections when RtpTransceivers are created but not yet associated with a m= section, or if RtpTransceivers have been stopped and disassociated from m= sections. An RtpTransceiver is said to be associated with an m= section if its mid property is non-null; otherwise it is said to be disassociated. The associated m= section is determined using a mapping between transceivers and m= section indices, formed when creating an offer or applying a remote offer.</p>
<p id="rfc.section.3.4.1.p.3">An RtpTransceiver is never associated with more than one m= section, and once a session description is applied, a m= section is always associated with exactly one RtpTransceiver.  However, in certain cases where a m= section has been rejected, as discussed in <a href="#sec.subsequent-offers" class="xref">Section 5.2.2</a> below, that m= section will be "recycled" and associated with a new RtpTransceiver with a new mid value.</p>
<p id="rfc.section.3.4.1.p.4">RtpTransceivers can be created explicitly by the application or implicitly by calling setRemoteDescription with an offer that adds new m= sections.</p>
<h3 id="rfc.section.3.4.2">
<a href="#rfc.section.3.4.2">3.4.2.</a> <a href="#sec.rtpsenders" id="sec.rtpsenders">RtpSenders</a>
</h3>
<p id="rfc.section.3.4.2.p.1">RtpSenders allow the application to control how RTP media is sent. An RtpSender is conceptually responsible for the outgoing RTP stream(s) described by an m= section. This includes encoding the attached MediaStreamTrack, sending RTP media packets, and generating/processing RTCP for the outgoing RTP streams(s).</p>
<h3 id="rfc.section.3.4.3">
<a href="#rfc.section.3.4.3">3.4.3.</a> <a href="#sec.rtpreceivers" id="sec.rtpreceivers">RtpReceivers</a>
</h3>
<p id="rfc.section.3.4.3.p.1">RtpReceivers allow the application to inspect how RTP media is received. An RtpReceiver is conceptually responsible for the incoming RTP stream(s) described by an m= section.  This includes processing received RTP media packets, decoding the incoming stream(s) to produce a remote MediaStreamTrack, and generating/processing RTCP for the incoming RTP stream(s).</p>
<h2 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> <a href="#sec.ice" id="sec.ice">ICE</a>
</h2>
<h3 id="rfc.section.3.5.1">
<a href="#rfc.section.3.5.1">3.5.1.</a> <a href="#sec.ice-gather-overview" id="sec.ice-gather-overview">ICE Gathering Overview</a>
</h3>
<p id="rfc.section.3.5.1.p.1">JSEP gathers ICE candidates as needed by the application.  Collection of ICE candidates is referred to as a gathering phase, and this is triggered either by the addition of a new or recycled m= section to the local session description, or new ICE credentials in the description, indicating an ICE restart. Use of new ICE credentials can be triggered explicitly by the application, or implicitly by the JSEP implementation in response to changes in the ICE configuration.</p>
<p id="rfc.section.3.5.1.p.2">When the ICE configuration changes in a way that requires a new gathering phase, a 'needs-ice-restart' bit is set. When this bit is set, calls to the createOffer API will generate new ICE credentials. This bit is cleared by a call to the setLocalDescription API with new ICE credentials from either an offer or an answer, i.e., from either a local- or remote-initiated ICE restart.</p>
<p id="rfc.section.3.5.1.p.3">When a new gathering phase starts, the ICE agent will notify the application that gathering is occurring through an event. Then, when each new ICE candidate becomes available, the ICE agent will supply it to the application via an additional event; these candidates will also automatically be added to the current and/or pending local session description. Finally, when all candidates have been gathered, an event will be dispatched to signal that the gathering process is complete.</p>
<p id="rfc.section.3.5.1.p.4">Note that gathering phases only gather the candidates needed by new/recycled/restarting m= sections; other m= sections continue to use their existing candidates. Also, if an m= section is bundled (either by a successful bundle negotiation or by being marked as bundle-only), then candidates will be gathered and exchanged for that m= section if and only if its MID is a BUNDLE-tag, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>.</p>
<h3 id="rfc.section.3.5.2">
<a href="#rfc.section.3.5.2">3.5.2.</a> <a href="#sec.ice-candidate-trickling" id="sec.ice-candidate-trickling">ICE Candidate Trickling</a>
</h3>
<p id="rfc.section.3.5.2.p.1">Candidate trickling is a technique through which a caller may incrementally provide candidates to the callee after the initial offer has been dispatched; the semantics of "Trickle ICE" are defined in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>. This process allows the callee to begin acting upon the call and setting up the ICE (and perhaps DTLS) connections immediately, without having to wait for the caller to gather all possible candidates. This results in faster media setup in cases where gathering is not performed prior to initiating the call.</p>
<p id="rfc.section.3.5.2.p.2">JSEP supports optional candidate trickling by providing APIs, as described above, that provide control and feedback on the ICE candidate gathering process. Applications that support candidate trickling can send the initial offer immediately and send individual candidates when they get the notified of a new candidate; applications that do not support this feature can simply wait for the indication that gathering is complete, and then create and send their offer, with all the candidates, at this time.</p>
<p id="rfc.section.3.5.2.p.3">Upon receipt of trickled candidates, the receiving application will supply them to its ICE agent. This triggers the ICE agent to start using the new remote candidates for connectivity checks.</p>
<h4 id="rfc.section.3.5.2.1">
<a href="#rfc.section.3.5.2.1">3.5.2.1.</a> <a href="#sec.ice-candidate-format" id="sec.ice-candidate-format">ICE Candidate Format</a>
</h4>
<p id="rfc.section.3.5.2.1.p.1">In JSEP, ICE candidates are abstracted by an IceCandidate object, and as with session descriptions, SDP syntax is used for the internal representation.</p>
<p id="rfc.section.3.5.2.1.p.2">The candidate details are specified in an IceCandidate field, using the same SDP syntax as the "candidate-attribute" field defined in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.1. Note that this field does not contain an "a=" prefix, as indicated in the following example:</p>
<pre>
                
candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host

</pre>
<p id="rfc.section.3.5.2.1.p.3">The IceCandidate object contains a field to indicate which ICE ufrag it is associated with, as defined in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4. This value is used to determine which session description (and thereby which gathering phase) this IceCandidate belongs to, which helps resolve ambiguities during ICE restarts. If this field is absent in a received IceCandidate (perhaps when communicating with a non-JSEP endpoint), the most recently received session description is assumed.</p>
<p id="rfc.section.3.5.2.1.p.4">The IceCandidate object also contains fields to indicate which m= section it is associated with, which can be identified in one of two ways, either by a m= section index, or a MID. The m= section index is a zero-based index, with index N referring to the N+1th m= section in the session description referenced by this IceCandidate.  The MID is a "media stream identification" value, as defined in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 4, which provides a more robust way to identify the m= section in the session description, using the MID of the associated RtpTransceiver object (which may have been locally generated by the answerer when interacting with a non-JSEP endpoint that does not support the MID attribute, as discussed in <a href="#sec.applying-a-remote-desc" class="xref">Section 5.10</a> below). If the MID field is present in a received IceCandidate, it MUST be used for identification; otherwise, the m= section index is used instead.</p>
<p id="rfc.section.3.5.2.1.p.5">When creating an IceCandidate object, JSEP implementations MUST populate each of the candidate, ufrag, m= section index, and MID fields. Implementations MUST also be prepared to receive objects with some fields missing, as mentioned above.</p>
<h3 id="rfc.section.3.5.3">
<a href="#rfc.section.3.5.3">3.5.3.</a> <a href="#sec.ice-candidate-policy" id="sec.ice-candidate-policy">ICE Candidate Policy</a>
</h3>
<p id="rfc.section.3.5.3.p.1">Typically, when gathering ICE candidates, the JSEP implementation will gather all possible forms of initial candidates - host, server reflexive, and relay. However, in certain cases, applications may want to have more specific control over the gathering process, due to privacy or related concerns. For example, one may want to only use relay candidates, to leak as little location information as possible (keeping in mind that this choice comes with corresponding operational costs). To accomplish this, JSEP allows the application to restrict which ICE candidates are used in a session. Note that this filtering is applied on top of any restrictions the implementation chooses to enforce regarding which IP addresses are permitted for the application, as discussed in <a href="#I-D.ietf-rtcweb-ip-handling" class="xref">[I-D.ietf-rtcweb-ip-handling]</a>.</p>
<p id="rfc.section.3.5.3.p.2">There may also be cases where the application wants to change which types of candidates are used while the session is active. A prime example is where a callee may initially want to use only relay candidates, to avoid leaking location information to an arbitrary caller, but then change to use all candidates (for lower operational cost) once the user has indicated they want to take the call. For this scenario, the JSEP implementation MUST allow the candidate policy to be changed in mid-session, subject to the aforementioned interactions with local policy.</p>
<p id="rfc.section.3.5.3.p.3">To administer the ICE candidate policy, the JSEP implementation will determine the current setting at the start of each gathering phase. Then, during the gathering phase, the implementation MUST NOT expose candidates disallowed by the current policy to the application, use them as the source of connectivity checks, or indirectly expose them via other fields, such as the raddr/rport attributes for other ICE candidates. Later, if a different policy is specified by the application, the application can apply it by kicking off a new gathering phase via an ICE restart.</p>
<h3 id="rfc.section.3.5.4">
<a href="#rfc.section.3.5.4">3.5.4.</a> <a href="#sec.ice-candidate-pool" id="sec.ice-candidate-pool">ICE Candidate Pool</a>
</h3>
<p id="rfc.section.3.5.4.p.1">JSEP applications typically inform the JSEP implementation to begin ICE gathering via the information supplied to setLocalDescription, as the local description indicates the number of ICE components which will be needed and for which candidates must be gathered. However, to accelerate cases where the application knows the number of ICE components to use ahead of time, it may ask the implementation to gather a pool of potential ICE candidates to help ensure rapid media setup.</p>
<p id="rfc.section.3.5.4.p.2">When setLocalDescription is eventually called, and the JSEP implementation goes to gather the needed ICE candidates, it SHOULD start by checking if any candidates are available in the pool. If there are candidates in the pool, they SHOULD be handed to the application immediately via the ICE candidate event. If the pool becomes depleted, either because a larger-than-expected number of ICE components is used, or because the pool has not had enough time to gather candidates, the remaining candidates are gathered as usual.  This only occurs for the first offer/answer exchange, after which the candidate pool is emptied and no longer used.</p>
<p id="rfc.section.3.5.4.p.3">One example of where this concept is useful is an application that expects an incoming call at some point in the future, and wants to minimize the time it takes to establish connectivity, to avoid clipping of initial media.  By pre-gathering candidates into the pool, it can exchange and start sending connectivity checks from these candidates almost immediately upon receipt of a call. Note though that by holding on to these pre-gathered candidates, which will be kept alive as long as they may be needed, the application will consume resources on the STUN/TURN servers it is using.</p>
<h3 id="rfc.section.3.5.5">
<a href="#rfc.section.3.5.5">3.5.5.</a> ICE Versions</h3>
<p id="rfc.section.3.5.5.p.1">While this specification formally relies on <a href="#RFC8445" class="xref">[RFC8445]</a>, at the time of its publication, the majority of WebRTC implementations support the version of ICE described in <a href="#RFC5245" class="xref">[RFC5245]</a>. The use of the "ice2" attribute defined in <a href="#RFC8445" class="xref">[RFC8445]</a> can be used to detect the version in use by a remote endpoint and to provide a smooth transition from the older specification to the newer one.  Implementations MUST be able to accept remote descriptions that do not have the "ice2" attribute.</p>
<h2 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> <a href="#sec.imageattr" id="sec.imageattr">Video Size Negotiation</a>
</h2>
<p id="rfc.section.3.6.p.1">Video size negotiation is the process through which a receiver can use the "a=imageattr" SDP attribute <a href="#RFC6236" class="xref">[RFC6236]</a> to indicate what video frame sizes it is capable of receiving. A receiver may have hard limits on what its video decoder can process, or it may have some maximum set by policy. By specifying these limits in an "a=imageattr" attribute, JSEP endpoints can attempt to ensure that the remote sender transmits video at an acceptable resolution. However, when communicating with a non-JSEP endpoint that does not understand this attribute, any signaled limits may be exceeded, and the JSEP implementation MUST handle this gracefully, e.g., by discarding the video.</p>
<p id="rfc.section.3.6.p.2">Note that certain codecs support transmission of samples with aspect ratios other than 1.0 (i.e., non-square pixels).  JSEP implementations will not transmit non-square pixels, but SHOULD receive and render such video with the correct aspect ratio. However, sample aspect ratio has no impact on the size negotiation described below; all dimensions are measured in pixels, whether square or not.</p>
<h3 id="rfc.section.3.6.1">
<a href="#rfc.section.3.6.1">3.6.1.</a> <a href="#sec.creating-imageattr" id="sec.creating-imageattr">Creating an imageattr Attribute</a>
</h3>
<p id="rfc.section.3.6.1.p.1">The receiver will first intersect any known local limits (e.g., hardware decoder capababilities, local policy) to determine the absolute minimum and maximum sizes it can receive. If there are no known local limits, the "a=imageattr" attribute SHOULD be omitted. If these local limits preclude receiving any video, i.e., the degenerate case of no permitted resolutions, the "a=imageattr" attribute MUST be omitted, and the m= section MUST be marked as sendonly/inactive, as appropriate.</p>
<p id="rfc.section.3.6.1.p.2">Otherwise, an "a=imageattr" attribute is created with "recv" direction, and the resulting resolution space formed from the aforementioned intersection is used to specify its minimum and maximum x= and y= values.</p>
<p id="rfc.section.3.6.1.p.3">The rules here express a single set of preferences, and therefore, the "a=imageattr" q= value is not important. It SHOULD be set to 1.0.</p>
<p id="rfc.section.3.6.1.p.4">The "a=imageattr" field is payload type specific. When all video codecs supported have the same capabilities, use of a single attribute, with the wildcard payload type (*), is RECOMMENDED. However, when the supported video codecs have different limitations, specific "a=imageattr" attributes MUST be inserted for each payload type.</p>
<p id="rfc.section.3.6.1.p.5">As an example, consider a system with a multiformat video decoder, which is capable of decoding any resolution from 48x48 to 720p, In this case, the implementation would generate this attribute:</p>
<p id="rfc.section.3.6.1.p.6">a=imageattr:* recv [x=[48:1280],y=[48:720],q=1.0]</p>
<p id="rfc.section.3.6.1.p.7">This declaration indicates that the receiver is capable of decoding any image resolution from 48x48 up to 1280x720 pixels.</p>
<h3 id="rfc.section.3.6.2">
<a href="#rfc.section.3.6.2">3.6.2.</a> <a href="#sec.interpreting-imageattr" id="sec.interpreting-imageattr">Interpreting imageattr Attributes</a>
</h3>
<p><a href="#RFC6236" class="xref">[RFC6236]</a> defines "a=imageattr" to be an advisory field. This means that it does not absolutely constrain the video formats that the sender can use, but gives an indication of the preferred values.</p>
<p id="rfc.section.3.6.2.p.2">This specification prescribes more specific behavior. When a MediaStreamTrack, which is producing video of a certain resolution (the "track resolution"), is attached to a RtpSender, which is encoding the track video at the same or lower resolution(s) (the "encoder resolutions"), and a remote description is applied that references the sender and contains valid "a=imageattr recv" attributes, it MUST follow the rules below to ensure the sender does not transmit a resolution that would exceed the size criteria specified in the attributes. These rules MUST be followed as long as the attributes remain present in the remote description, including cases in which the track changes its resolution, or is replaced with a different track.</p>
<p id="rfc.section.3.6.2.p.3">Depending on how the RtpSender is configured, it may be producing a single encoding at a certain resolution, or, if simulcast <a href="#sec.simulcast" class="xref">Section 3.7</a> has been negotiated, multiple encodings, each at their own specific resolution. In addition, depending on the configuration, each encoding may have the flexibility to reduce resolution when needed, or may be locked to a specific output resolution.</p>
<p id="rfc.section.3.6.2.p.4">For each encoding being produced by the RtpSender, the set of "a=imageattr recv" attributes in the corresponding m= section of the remote description is processed to determine what should be transmitted. Only attributes that reference the media format selected for the encoding are considered; each such attribute is evaluated individually, starting with the attribute with the highest "q=" value. If multiple attributes have the same "q=" value, they are evaluated in the order they appear in their containing m= section. Note that while JSEP endpoints will include at most one "a=imageattr recv" attribute per media format, JSEP endpoints may receive session descriptions from non-JSEP endpoints with m= sections that contain multiple such attributes.</p>
<p id="rfc.section.3.6.2.p.5">For each "a=imageattr recv" attribute, the following rules are applied. If this processing is successful, the encoding is transmitted accordingly, and no further attributes are considered for that encoding. Otherwise, the next attribute is evaluated, in the aforementioned order. If none of the supplied attributes can be processed successfully, the encoding MUST NOT be transmitted, and an error SHOULD be raised to the application.  </p>

<ul>
<li>The limits from the attribute are compared to the encoder resolution. Only the specific limits mentioned below are considered; any other values, such as picture aspect ratio, MUST be ignored. When considering a MediaStreamTrack that is producing rotated video, the unrotated resolution MUST be used for the checks. This is required regardless of whether the receiver supports performing receive-side rotation (e.g., through CVO <a href="#TS26.114" class="xref">[TS26.114]</a>), as it significantly simplifies the matching logic.</li>
<li>If the attribute includes a "sar=" (sample aspect ratio) value set to something other than "1.0", indicating the receiver wants to receive non-square pixels, this cannot be satisfied and the attribute MUST NOT be used.</li>
<li>If the encoder resolution exceeds the maximum size permitted by the attribute, and the encoder is allowed to adjust its resolution, the encoder SHOULD apply downscaling in order to satisfy the limits. Downscaling MUST NOT change the picture aspect ratio of the encoding, ignoring any trivial differences due to rounding. For example, if the encoder resolution is 1280x720, and the attribute specified a maximum of 640x480, the expected output resolution would be 640x360. If downscaling cannot be applied, the attribute MUST NOT be used.</li>
<li>If the encoder resolution is less than the minimum size permitted by the attribute, the attribute MUST NOT be used; the encoder MUST NOT apply upscaling. JSEP implementations SHOULD avoid this situation by allowing receipt of arbitrarily small resolutions, perhaps via fallback to a software decoder.</li>
<li>If the encoder resolution is within the maximum and minimum sizes, no action is needed.</li>
</ul>
<h2 id="rfc.section.3.7">
<a href="#rfc.section.3.7">3.7.</a> <a href="#sec.simulcast" id="sec.simulcast">Simulcast</a>
</h2>
<p id="rfc.section.3.7.p.1">JSEP supports simulcast transmission of a MediaStreamTrack, where multiple encodings of the source media can be transmitted within the context of a single m= section. The current JSEP API is designed to allow applications to send simulcasted media but only to receive a single encoding. This allows for multi-user scenarios where each sending client sends multiple encodings to a server, which then, for each receiving client, chooses the appropriate encoding to forward.</p>
<p id="rfc.section.3.7.p.2">Applications request support for simulcast by configuring multiple encodings on an RtpSender. Upon generation of an offer or answer, these encodings are indicated via SDP markings on the corresponding m= section, as described below. Receivers that understand simulcast and are willing to receive it will also include SDP markings to indicate their support, and JSEP endpoints will use these markings to determine whether simulcast is permitted for a given RtpSender. If simulcast support is not negotiated, the RtpSender will only use the first configured encoding.</p>
<p id="rfc.section.3.7.p.3">Note that the exact simulcast parameters are up to the sending application. While the aforementioned SDP markings are provided to ensure the remote side can receive and demux multiple simulcast encodings, the specific resolutions and bitrates to be used for each encoding are purely a send-side decision in JSEP.</p>
<p id="rfc.section.3.7.p.4">JSEP currently does not provide a mechanism to configure receipt of simulcast. This means that if simulcast is offered by the remote endpoint, the answer generated by a JSEP endpoint will not indicate support for receipt of simulcast, and as such the remote endpoint will only send a single encoding per m= section.</p>
<p id="rfc.section.3.7.p.5">In addition, JSEP does not provide a mechanism to handle an incoming offer requesting simulcast from the JSEP endpoint.  This means that setting up simulcast in the case where the JSEP endpoint receives the initial offer requires out-of-band signaling or SDP inspection. However, in the case where the JSEP endpoint sets up simulcast in its in initial offer, any established simulcast streams will continue to work upon receipt of an incoming re-offer. Future versions of this specification may add additional APIs to handle the incoming initial offer scenario.</p>
<p id="rfc.section.3.7.p.6">When using JSEP to transmit multiple encodings from a RtpSender, the techniques from <a href="#I-D.ietf-mmusic-sdp-simulcast" class="xref">[I-D.ietf-mmusic-sdp-simulcast]</a> and <a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a> are used. Specifically, when multiple encodings have been configured for a RtpSender, the m= section for the RtpSender will include an "a=simulcast" attribute, as defined in <a href="#I-D.ietf-mmusic-sdp-simulcast" class="xref">[I-D.ietf-mmusic-sdp-simulcast]</a>, Section 6.2, with a "send" simulcast stream description that lists each desired encoding, and no "recv" simulcast stream description.  The m= section will also include an "a=rid" attribute for each encoding, as specified in <a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a>, Section 4; the use of RID identifiers allows the individual encodings to be disambiguated even though they are all part of the same m= section.</p>
<h2 id="rfc.section.3.8">
<a href="#rfc.section.3.8">3.8.</a> <a href="#sec.interactions-with-forking" id="sec.interactions-with-forking">Interactions With Forking</a>
</h2>
<p id="rfc.section.3.8.p.1">Some call signaling systems allow various types of forking where an SDP Offer may be provided to more than one device. For example, SIP <a href="#RFC3261" class="xref">[RFC3261]</a> defines both a "Parallel Search" and "Sequential Search". Although these are primarily signaling level issues that are outside the scope of JSEP, they do have some impact on the configuration of the media plane that is relevant. When forking happens at the signaling layer, the JavaScript application responsible for the signaling needs to make the decisions about what media should be sent or received at any point of time, as well as which remote endpoint it should communicate with; JSEP is used to make sure the media engine can make the RTP and media perform as required by the application. The basic operations that the applications can have the media engine do are: </p>

<ul>
<li>Start exchanging media with a given remote peer, but keep all the resources reserved in the offer.</li>
<li>Start exchanging media with a given remote peer, and free any resources in the offer that are not being used.</li>
</ul>
<h3 id="rfc.section.3.8.1">
<a href="#rfc.section.3.8.1">3.8.1.</a> <a href="#sec.sequential-forking" id="sec.sequential-forking">Sequential Forking</a>
</h3>
<p id="rfc.section.3.8.1.p.1">Sequential forking involves a call being dispatched to multiple remote callees, where each callee can accept the call, but only one active session ever exists at a time; no mixing of received media is performed.</p>
<p id="rfc.section.3.8.1.p.2">JSEP handles sequential forking well, allowing the application to easily control the policy for selecting the desired remote endpoint. When an answer arrives from one of the callees, the application can choose to apply it either as a provisional answer, leaving open the possibility of using a different answer in the future, or apply it as a final answer, ending the setup flow.</p>
<p id="rfc.section.3.8.1.p.3">In a "first-one-wins" situation, the first answer will be applied as a final answer, and the application will reject any subsequent answers. In SIP parlance, this would be ACK + BYE.</p>
<p id="rfc.section.3.8.1.p.4">In a "last-one-wins" situation, all answers would be applied as provisional answers, and any previous call leg will be terminated. At some point, the application will end the setup process, perhaps with a timer; at this point, the application could reapply the pending remote description as a final answer.</p>
<h3 id="rfc.section.3.8.2">
<a href="#rfc.section.3.8.2">3.8.2.</a> <a href="#sec.parallel-forking" id="sec.parallel-forking">Parallel Forking</a>
</h3>
<p id="rfc.section.3.8.2.p.1">Parallel forking involves a call being dispatched to multiple remote callees, where each callee can accept the call, and multiple simultaneous active signaling sessions can be established as a result. If multiple callees send media at the same time, the possibilities for handling this are described in <a href="#RFC3960" class="xref">[RFC3960]</a>, Section 3.1. Most SIP devices today only support exchanging media with a single device at a time, and do not try to mix multiple early media audio sources, as that could result in a confusing situation. For example, consider having a European ringback tone mixed together with the North American ringback tone - the resulting sound would not be like either tone, and would confuse the user. If the signaling application wishes to only exchange media with one of the remote endpoints at a time, then from a media engine point of view, this is exactly like the sequential forking case.</p>
<p id="rfc.section.3.8.2.p.2">In the parallel forking case where the JavaScript application wishes to simultaneously exchange media with multiple peers, the flow is slightly more complex, but the JavaScript application can follow the strategy that <a href="#RFC3960" class="xref">[RFC3960]</a> describes using UPDATE. The UPDATE approach allows the signaling to set up a separate media flow for each peer that it wishes to exchange media with. In JSEP, this offer used in the UPDATE would be formed by simply creating a new PeerConnection (see <a href="#sec.peerconnection" class="xref">Section 4.1</a>) and making sure that the same local media streams have been added into this new PeerConnection. Then the new PeerConnection object would produce a SDP offer that could be used by the signaling to perform the UPDATE strategy discussed in <a href="#RFC3960" class="xref">[RFC3960]</a>.</p>
<p id="rfc.section.3.8.2.p.3">As a result of sharing the media streams, the application will end up with N parallel PeerConnection sessions, each with a local and remote description and their own local and remote addresses. The media flow from these sessions can be managed using setDirection (see <a href="#sec.transceiver-set-direction" class="xref">Section 4.2.3</a>), or the application can choose to play out the media from all sessions mixed together. Of course, if the application wants to only keep a single session, it can simply terminate the sessions that it no longer needs.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#sec.interface" id="sec.interface">Interface</a>
</h1>
<p id="rfc.section.4.p.1">This section details the basic operations that must be present to implement JSEP functionality. The actual API exposed in the W3C API may have somewhat different syntax, but should map easily to these concepts.</p>
<h2 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#sec.peerconnection" id="sec.peerconnection">PeerConnection</a>
</h2>
<h3 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#sec.pc-constructor" id="sec.pc-constructor">Constructor</a>
</h3>
<p id="rfc.section.4.1.1.p.1">The PeerConnection constructor allows the application to specify global parameters for the media session, such as the STUN/TURN servers and credentials to use when gathering candidates, as well as the initial ICE candidate policy and pool size, and also the bundle policy to use.</p>
<p id="rfc.section.4.1.1.p.2">If an ICE candidate policy is specified, it functions as described in <a href="#sec.ice-candidate-policy" class="xref">Section 3.5.3</a>, causing the JSEP implementation to only surface the permitted candidates (including any implementation-internal filtering) to the application, and only use those candidates for connectivity checks. The set of available policies is as follows: </p>

<dl>
<dt>all:</dt>
<dd style="margin-left: 8">All candidates permitted by implementation policy will be gathered and used.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>relay:</dt>
<dd style="margin-left: 8">All candidates except relay candidates will be filtered out. This obfuscates the location information that might be ascertained by the remote peer from the received candidates. Depending on how the application deploys and chooses relay servers, this could obfuscate location to a metro or possibly even global level.</dd>
</dl>
<p id="rfc.section.4.1.1.p.3">The default ICE candidate policy MUST be set to "all" as this is generally the desired policy, and also typically reduces use of application TURN server resources significantly.</p>
<p id="rfc.section.4.1.1.p.4">If a size is specified for the ICE candidate pool, this indicates the number of ICE components to pre-gather candidates for. Because pre-gathering results in utilizing STUN/TURN server resources for potentially long periods of time, this must only occur upon application request, and therefore the default candidate pool size MUST be zero.</p>
<p id="rfc.section.4.1.1.p.5">The application can specify its preferred policy regarding use of bundle, the multiplexing mechanism defined in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>. Regardless of policy, the application will always try to negotiate bundle onto a single transport, and will offer a single bundle group across all m= sections; use of this single transport is contingent upon the answerer accepting bundle. However, by specifying a policy from the list below, the application can control exactly how aggressively it will try to bundle media streams together, which affects how it will interoperate with a non-bundle-aware endpoint. When negotiating with a non-bundle-aware endpoint, only the streams not marked as bundle-only streams will be established.</p>
<p id="rfc.section.4.1.1.p.6">The set of available policies is as follows: </p>

<dl>
<dt>balanced:</dt>
<dd style="margin-left: 8">The first m= section of each type (audio, video, or application) will contain transport parameters, which will allow an answerer to unbundle that section. The second and any subsequent m= section of each type will be marked bundle-only. The result is that if there are N distinct media types, then candidates will be gathered for for N media streams. This policy balances desire to multiplex with the need to ensure basic audio and video can still be negotiated in legacy cases. When acting as answerer, if there is no bundle group in the offer, the implementation will reject all but the first m= section of each type.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>max-compat:</dt>
<dd style="margin-left: 8">All m= sections will contain transport parameters; none will be marked as bundle-only.  This policy will allow all streams to be received by non-bundle-aware endpoints, but require separate candidates to be gathered for each media stream.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt>max-bundle:</dt>
<dd style="margin-left: 8">Only the first m= section will contain transport parameters; all streams other than the first will be marked as bundle-only. This policy aims to minimize candidate gathering and maximize multiplexing, at the cost of less compatibility with legacy endpoints. When acting as answerer, the implementation will reject any m= sections other than the first m= section, unless they are in the same bundle group as that m= section.</dd>
</dl>
<p id="rfc.section.4.1.1.p.7">As it provides the best tradeoff between performance and compatibility with legacy endpoints, the default bundle policy MUST be set to "balanced".</p>
<p id="rfc.section.4.1.1.p.8">The application can specify its preferred policy regarding use of RTP/RTCP multiplexing <a href="#RFC5761" class="xref">[RFC5761]</a> using one of the following policies: </p>

<dl>
<dt>negotiate:</dt>
<dd style="margin-left: 8">The JSEP implementation will gather both RTP and RTCP candidates but also will offer "a=rtcp-mux", thus allowing for compatibility with either multiplexing or non-multiplexing endpoints.</dd>
<dt>require:</dt>
<dd style="margin-left: 8">The JSEP implementation will only gather RTP candidates and will insert an "a=rtcp-mux-only" indication into any new m= sections in offers it generates.  This halves the number of candidates that the offerer needs to gather. Applying a description with an m= section that does not contain an "a=rtcp-mux" attribute will cause an error to be returned.</dd>
</dl>
<p id="rfc.section.4.1.1.p.9">The default multiplexing policy MUST be set to "require".  Implementations MAY choose to reject attempts by the application to set the multiplexing policy to "negotiate".</p>
<h3 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#sec.addTrack" id="sec.addTrack">addTrack</a>
</h3>
<p id="rfc.section.4.1.2.p.1">The addTrack method adds a MediaStreamTrack to the PeerConnection, using the MediaStream argument to associate the track with other tracks in the same MediaStream, so that they can be added to the same "LS" group when creating an offer or answer. Adding tracks to the same "LS" group indicates that the playback of these tracks should be synchronized for proper lip sync, as described in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 7. addTrack attempts to minimize the number of transceivers as follows: If the PeerConnection is in the "have-remote-offer" state, the track will be attached to the first compatible transceiver that was created by the most recent call to setRemoteDescription() and does not have a local track. Otherwise, a new transceiver will be created, as described in <a href="#sec.addTransceiver" class="xref">Section 4.1.4</a>.</p>
<h3 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#sec.removeTrack" id="sec.removeTrack">removeTrack</a>
</h3>
<p id="rfc.section.4.1.3.p.1">The removeTrack method removes a MediaStreamTrack from the PeerConnection, using the RtpSender argument to indicate which sender should have its track removed. The sender's track is cleared, and the sender stops sending. Future calls to createOffer will mark the m= section associated with the sender as recvonly (if transceiver.direction is sendrecv) or as inactive (if transceiver.direction is sendonly).</p>
<h3 id="rfc.section.4.1.4">
<a href="#rfc.section.4.1.4">4.1.4.</a> <a href="#sec.addTransceiver" id="sec.addTransceiver">addTransceiver</a>
</h3>
<p id="rfc.section.4.1.4.p.1">The addTransceiver method adds a new RtpTransceiver to the PeerConnection. If a MediaStreamTrack argument is provided, then the transceiver will be configured with that media type and the track will be attached to the transceiver. Otherwise, the application MUST explicitly specify the type; this mode is useful for creating recvonly transceivers as well as for creating transceivers to which a track can be attached at some later point.</p>
<p id="rfc.section.4.1.4.p.2">At the time of creation, the application can also specify a transceiver direction attribute, a set of MediaStreams which the transceiver is associated with (allowing LS group assignments), and a set of encodings for the media (used for simulcast as described in <a href="#sec.simulcast" class="xref">Section 3.7</a>).</p>
<h3 id="rfc.section.4.1.5">
<a href="#rfc.section.4.1.5">4.1.5.</a> <a href="#sec.createDataChannel" id="sec.createDataChannel">createDataChannel</a>
</h3>
<p id="rfc.section.4.1.5.p.1">The createDataChannel method creates a new data channel and attaches it to the PeerConnection. If no data channel currently exists for this PeerConnection, then a new offer/answer exchange is required. All data channels on a given PeerConnection share the same SCTP/DTLS association and therefore the same m= section, so subsequent creation of data channels does not have any impact on the JSEP state.</p>
<p id="rfc.section.4.1.5.p.2">The createDataChannel method also includes a number of arguments which are used by the PeerConnection (e.g., maxPacketLifetime) but are not reflected in the SDP and do not affect the JSEP state.</p>
<h3 id="rfc.section.4.1.6">
<a href="#rfc.section.4.1.6">4.1.6.</a> <a href="#sec.createoffer" id="sec.createoffer">createOffer</a>
</h3>
<p id="rfc.section.4.1.6.p.1">The createOffer method generates a blob of SDP that contains a <a href="#RFC3264" class="xref">[RFC3264]</a> offer with the supported configurations for the session, including descriptions of the media added to this PeerConnection, the codec/RTP/RTCP options supported by this implementation, and any candidates that have been gathered by the ICE agent. An options parameter may be supplied to provide additional control over the generated offer. This options parameter allows an application to trigger an ICE restart, for the purpose of reestablishing connectivity.</p>
<p id="rfc.section.4.1.6.p.2">In the initial offer, the generated SDP will contain all desired functionality for the session (functionality that is supported but not desired by default may be omitted); for each SDP line, the generation of the SDP will follow the process defined for generating an initial offer from the document that specifies the given SDP line. The exact handling of initial offer generation is detailed in <a href="#sec.initial-offers" class="xref">Section 5.2.1</a> below.</p>
<p id="rfc.section.4.1.6.p.3">In the event createOffer is called after the session is established, createOffer will generate an offer to modify the current session based on any changes that have been made to the session, e.g., adding or stopping RtpTransceivers, or requesting an ICE restart. For each existing stream, the generation of each SDP line must follow the process defined for generating an updated offer from the RFC that specifies the given SDP line. For each new stream, the generation of the SDP must follow the process of generating an initial offer, as mentioned above. If no changes have been made, or for SDP lines that are unaffected by the requested changes, the offer will only contain the parameters negotiated by the last offer-answer exchange. The exact handling of subsequent offer generation is detailed in <a href="#sec.subsequent-offers" class="xref">Section 5.2.2</a>. below.</p>
<p id="rfc.section.4.1.6.p.4">Session descriptions generated by createOffer must be immediately usable by setLocalDescription; if a system has limited resources (e.g. a finite number of decoders), createOffer should return an offer that reflects the current state of the system, so that setLocalDescription will succeed when it attempts to acquire those resources.</p>
<p id="rfc.section.4.1.6.p.5">Calling this method may do things such as generating new ICE credentials, but does not change the PeerConnection state, trigger candidate gathering, or cause media to start or stop flowing. Specifically, the offer is not applied, and does not become the pending local description, until setLocalDescription is called.</p>
<h3 id="rfc.section.4.1.7">
<a href="#rfc.section.4.1.7">4.1.7.</a> <a href="#sec.createanswer" id="sec.createanswer">createAnswer</a>
</h3>
<p id="rfc.section.4.1.7.p.1">The createAnswer method generates a blob of SDP that contains a <a href="#RFC3264" class="xref">[RFC3264]</a> SDP answer with the supported configuration for the session that is compatible with the parameters supplied in the most recent call to setRemoteDescription, which MUST have been called prior to calling createAnswer. Like createOffer, the returned blob contains descriptions of the media added to this PeerConnection, the codec/RTP/RTCP options negotiated for this session, and any candidates that have been gathered by the ICE agent. An options parameter may be supplied to provide additional control over the generated answer.</p>
<p id="rfc.section.4.1.7.p.2">As an answer, the generated SDP will contain a specific configuration that specifies how the media plane should be established; for each SDP line, the generation of the SDP must follow the process defined for generating an answer from the document that specifies the given SDP line. The exact handling of answer generation is detailed in <a href="#sec.generating-an-answer" class="xref">Section 5.3</a>. below.</p>
<p id="rfc.section.4.1.7.p.3">Session descriptions generated by createAnswer must be immediately usable by setLocalDescription; like createOffer, the returned description should reflect the current state of the system.</p>
<p id="rfc.section.4.1.7.p.4">Calling this method may do things such as generating new ICE credentials, but does not change the PeerConnection state, trigger candidate gathering, or or cause a media state change. Specifically, the answer is not applied, and does not become the current local description, until setLocalDescription is called.</p>
<h3 id="rfc.section.4.1.8">
<a href="#rfc.section.4.1.8">4.1.8.</a> <a href="#sec.sessiondescriptiontype" id="sec.sessiondescriptiontype">SessionDescriptionType</a>
</h3>
<p id="rfc.section.4.1.8.p.1">Session description objects (RTCSessionDescription) may be of type "offer", "pranswer", "answer" or "rollback". These types provide information as to how the description parameter should be parsed, and how the media state should be changed.</p>
<p id="rfc.section.4.1.8.p.2">"offer" indicates that a description should be parsed as an offer; said description may include many possible media configurations. A description used as an "offer" may be applied anytime the PeerConnection is in a stable state, or as an update to a previously supplied but unanswered "offer".</p>
<p id="rfc.section.4.1.8.p.3">"pranswer" indicates that a description should be parsed as an answer, but not a final answer, and so should not result in the freeing of allocated resources. It may result in the start of media transmission, if the answer does not specify an inactive media direction. A description used as a "pranswer" may be applied as a response to an "offer", or an update to a previously sent "pranswer".</p>
<p id="rfc.section.4.1.8.p.4">"answer" indicates that a description should be parsed as an answer, the offer-answer exchange should be considered complete, and any resources (decoders, candidates) that are no longer needed can be released. A description used as an "answer" may be applied as a response to an "offer", or an update to a previously sent "pranswer".</p>
<p id="rfc.section.4.1.8.p.5">The only difference between a provisional and final answer is that the final answer results in the freeing of any unused resources that were allocated as a result of the offer. As such, the application can use some discretion on whether an answer should be applied as provisional or final, and can change the type of the session description as needed. For example, in a serial forking scenario, an application may receive multiple "final" answers, one from each remote endpoint. The application could choose to accept the initial answers as provisional answers, and only apply an answer as final when it receives one that meets its criteria (e.g. a live user instead of voicemail).</p>
<p id="rfc.section.4.1.8.p.6">"rollback" is a special session description type implying that the state machine should be rolled back to the previous stable state, as described in <a href="#sec.rollback" class="xref">Section 4.1.8.2</a>. The contents MUST be empty.</p>
<h4 id="rfc.section.4.1.8.1">
<a href="#rfc.section.4.1.8.1">4.1.8.1.</a> <a href="#sec.use-of-provisional-answer" id="sec.use-of-provisional-answer">Use of Provisional Answers</a>
</h4>
<p id="rfc.section.4.1.8.1.p.1">Most applications will not need to create answers using the "pranswer" type. While it is good practice to send an immediate response to an offer, in order to warm up the session transport and prevent media clipping, the preferred handling for a JSEP application is to create and send a "sendonly" final answer with a null MediaStreamTrack immediately after receiving the offer, which will prevent media from being sent by the caller, and allow media to be sent immediately upon answer by the callee. Later, when the callee actually accepts the call, the application can plug in the real MediaStreamTrack and create a new "sendrecv" offer to update the previous offer/answer pair and start bidirectional media flow. While this could also be done with a "sendonly" pranswer, followed by a "sendrecv" answer, the initial pranswer leaves the offer-answer exchange open, which means that the caller cannot send an updated offer during this time.</p>
<p id="rfc.section.4.1.8.1.p.2">As an example, consider a typical JSEP application that wants to set up audio and video as quickly as possible.  When the callee receives an offer with audio and video MediaStreamTracks, it will send an immediate answer accepting these tracks as sendonly (meaning that the caller will not send the callee any media yet, and because the callee has not yet added its own MediaStreamTracks, the callee will not send any media either). It will then ask the user to accept the call and acquire the needed local tracks. Upon acceptance by the user, the application will plug in the tracks it has acquired, which, because ICE and DTLS handshaking have likely completed by this point, can start transmitting immediately. The application will also send a new offer to the remote side indicating call acceptance and moving the audio and video to be two-way media. A detailed example flow along these lines is shown in <a href="#sec.warmup-example" class="xref">Section 7.3</a>.</p>
<p id="rfc.section.4.1.8.1.p.3">Of course, some applications may not be able to perform this double offer-answer exchange, particularly ones that are attempting to gateway to legacy signaling protocols. In these cases, pranswer can still provide the application with a mechanism to warm up the transport.</p>
<h4 id="rfc.section.4.1.8.2">
<a href="#rfc.section.4.1.8.2">4.1.8.2.</a> <a href="#sec.rollback" id="sec.rollback">Rollback</a>
</h4>
<p id="rfc.section.4.1.8.2.p.1">In certain situations it may be desirable to "undo" a change made to setLocalDescription or setRemoteDescription.  Consider a case where a call is ongoing, and one side wants to change some of the session parameters; that side generates an updated offer and then calls setLocalDescription. However, the remote side, either before or after setRemoteDescription, decides it does not want to accept the new parameters, and sends a reject message back to the offerer. Now, the offerer, and possibly the answerer as well, need to return to a stable state and the previous local/remote description. To support this, we introduce the concept of "rollback", which discards any proposed changes to the session, returning the state machine to the stable state. A rollback is performed by supplying a session description of type "rollback" with empty contents to either setLocalDescription or setRemoteDescription.</p>
<h3 id="rfc.section.4.1.9">
<a href="#rfc.section.4.1.9">4.1.9.</a> <a href="#sec.setlocaldescription" id="sec.setlocaldescription">setLocalDescription</a>
</h3>
<p id="rfc.section.4.1.9.p.1">The setLocalDescription method instructs the PeerConnection to apply the supplied session description as its local configuration. The type field indicates whether the description should be processed as an offer, provisional answer, final answer, or rollback; offers and answers are checked differently, using the various rules that exist for each SDP line.</p>
<p id="rfc.section.4.1.9.p.2">This API changes the local media state; among other things, it sets up local resources for receiving and decoding media. In order to successfully handle scenarios where the application wants to offer to change from one media format to a different, incompatible format, the PeerConnection must be able to simultaneously support use of both the current and pending local descriptions (e.g., support the codecs that exist in either description). This dual processing begins when the PeerConnection enters the "have-local-offer" state, and continues until setRemoteDescription is called with either a final answer, at which point the PeerConnection can fully adopt the pending local description, or a rollback, which results in a revert to the current local description.</p>
<p id="rfc.section.4.1.9.p.3">This API indirectly controls the candidate gathering process. When a local description is supplied, and the number of transports currently in use does not match the number of transports needed by the local description, the PeerConnection will create transports as needed and begin gathering candidates for each transport, using ones from the candidate pool if available.</p>
<p id="rfc.section.4.1.9.p.4">If setRemoteDescription was previously called with an offer, and setLocalDescription is called with an answer (provisional or final), and the media directions are compatible, and media is available to send, this will result in the starting of media transmission.</p>
<h3 id="rfc.section.4.1.10">
<a href="#rfc.section.4.1.10">4.1.10.</a> <a href="#sec.setremotedescription" id="sec.setremotedescription">setRemoteDescription</a>
</h3>
<p id="rfc.section.4.1.10.p.1">The setRemoteDescription method instructs the PeerConnection to apply the supplied session description as the desired remote configuration. As in setLocalDescription, the type field of the description indicates how it should be processed.</p>
<p id="rfc.section.4.1.10.p.2">This API changes the local media state; among other things, it sets up local resources for sending and encoding media.</p>
<p id="rfc.section.4.1.10.p.3">If setLocalDescription was previously called with an offer, and setRemoteDescription is called with an answer (provisional or final), and the media directions are compatible, and media is available to send, this will result in the starting of media transmission.</p>
<h3 id="rfc.section.4.1.11">
<a href="#rfc.section.4.1.11">4.1.11.</a> <a href="#sec.currentlocaldescription" id="sec.currentlocaldescription">currentLocalDescription</a>
</h3>
<p id="rfc.section.4.1.11.p.1">The currentLocalDescription method returns the current negotiated local description - i.e., the local description from the last successful offer/answer exchange - in addition to any local candidates that have been generated by the ICE agent since the local description was set.</p>
<p id="rfc.section.4.1.11.p.2">A null object will be returned if an offer/answer exchange has not yet been completed.</p>
<h3 id="rfc.section.4.1.12">
<a href="#rfc.section.4.1.12">4.1.12.</a> <a href="#sec.pendinglocaldescription" id="sec.pendinglocaldescription">pendingLocalDescription</a>
</h3>
<p id="rfc.section.4.1.12.p.1">The pendingLocalDescription method returns a copy of the local description currently in negotiation - i.e., a local offer set without any corresponding remote answer - in addition to any local candidates that have been generated by the ICE agent since the local description was set.</p>
<p id="rfc.section.4.1.12.p.2">A null object will be returned if the state of the PeerConnection is "stable" or "have-remote-offer".</p>
<h3 id="rfc.section.4.1.13">
<a href="#rfc.section.4.1.13">4.1.13.</a> <a href="#sec.currentremotedescription" id="sec.currentremotedescription">currentRemoteDescription</a>
</h3>
<p id="rfc.section.4.1.13.p.1">The currentRemoteDescription method returns a copy of the current negotiated remote description - i.e., the remote description from the last successful offer/answer exchange - in addition to any remote candidates that have been supplied via processIceMessage since the remote description was set.</p>
<p id="rfc.section.4.1.13.p.2">A null object will be returned if an offer/answer exchange has not yet been completed.</p>
<h3 id="rfc.section.4.1.14">
<a href="#rfc.section.4.1.14">4.1.14.</a> <a href="#sec.pendingremotedescription" id="sec.pendingremotedescription">pendingRemoteDescription</a>
</h3>
<p id="rfc.section.4.1.14.p.1">The pendingRemoteDescription method returns a copy of the remote description currently in negotiation - i.e., a remote offer set without any corresponding local answer - in addition to any remote candidates that have been supplied via processIceMessage since the remote description was set.</p>
<p id="rfc.section.4.1.14.p.2">A null object will be returned if the state of the PeerConnection is "stable" or "have-local-offer".</p>
<h3 id="rfc.section.4.1.15">
<a href="#rfc.section.4.1.15">4.1.15.</a> <a href="#sec.cantrickle" id="sec.cantrickle">canTrickleIceCandidates</a>
</h3>
<p id="rfc.section.4.1.15.p.1">The canTrickleIceCandidates property indicates whether the remote side supports receiving trickled candidates. There are three potential values: </p>

<dl>
<dt>null:</dt>
<dd style="margin-left: 8">No SDP has been received from the other side, so it is not known if it can handle trickle. This is the initial value before setRemoteDescription() is called.</dd>
<dt>true:</dt>
<dd style="margin-left: 8">SDP has been received from the other side indicating that it can support trickle.</dd>
<dt>false:</dt>
<dd style="margin-left: 8">SDP has been received from the other side indicating that it cannot support trickle.</dd>
</dl>
<p id="rfc.section.4.1.15.p.2">As described in <a href="#sec.ice-candidate-trickling" class="xref">Section 3.5.2</a>, JSEP implementations always provide candidates to the application individually, consistent with what is needed for Trickle ICE.  However, applications can use the canTrickleIceCandidates property to determine whether their peer can actually do Trickle ICE, i.e., whether it is safe to send an initial offer or answer followed later by candidates as they are gathered. As "true" is the only value that definitively indicates remote Trickle ICE support, an application which compares canTrickleIceCandidates against "true" will by default attempt Half Trickle on initial offers and Full Trickle on subsequent interactions with a Trickle ICE-compatible agent.</p>
<h3 id="rfc.section.4.1.16">
<a href="#rfc.section.4.1.16">4.1.16.</a> <a href="#sec.setconfiguration" id="sec.setconfiguration">setConfiguration</a>
</h3>
<p id="rfc.section.4.1.16.p.1">The setConfiguration method allows the global configuration of the PeerConnection, which was initially set by constructor parameters, to be changed during the session.  The effects of this method call depend on when it is invoked, and differ depending on which specific parameters are changed:</p>
<p></p>

<ul>
<li>Any changes to the STUN/TURN servers to use affect the next gathering phase. If an ICE gathering phase has already started or completed, the 'needs-ice-restart' bit mentioned in <a href="#sec.ice-gather-overview" class="xref">Section 3.5.1</a> will be set.  This will cause the next call to createOffer to generate new ICE credentials, for the purpose of forcing an ICE restart and kicking off a new gathering phase, in which the new servers will be used. If the ICE candidate pool has a nonzero size, and a local description has not yet been applied, any existing candidates will be discarded, and new candidates will be gathered from the new servers.</li>
<li>Any change to the ICE candidate policy affects the next gathering phase. If an ICE gathering phase has already started or completed, the 'needs-ice-restart' bit will be set. Either way, changes to the policy have no effect on the candidate pool, because pooled candidates are not made available to the application until a gathering phase occurs, and so any necessary filtering can still be done on any pooled candidates.</li>
<li>The ICE candidate pool size MUST NOT be changed after applying a local description. If a local description has not yet been applied, any changes to the ICE candidate pool size take effect immediately; if increased, additional candidates are pre-gathered; if decreased, the now-superfluous candidates are discarded.</li>
<li>The bundle and RTCP-multiplexing policies MUST NOT be changed after the construction of the PeerConnection.</li>
</ul>

<p> </p>
<p id="rfc.section.4.1.16.p.3">This call may result in a change to the state of the ICE Agent.</p>
<h3 id="rfc.section.4.1.17">
<a href="#rfc.section.4.1.17">4.1.17.</a> <a href="#sec.addicecandidate" id="sec.addicecandidate">addIceCandidate</a>
</h3>
<p id="rfc.section.4.1.17.p.1">The addIceCandidate method provides an update to the ICE agent via an IceCandidate object <a href="#sec.ice-candidate-format" class="xref">Section 3.5.2.1</a>. If the IceCandidate's candidate field is filled in, the IceCandidate is treated as a new remote ICE candidate, which will be added to the current and/or pending remote description according to the rules defined for Trickle ICE. Otherwise, the IceCandidate is treated as an end-of-candidates indication, as defined in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>.</p>
<p id="rfc.section.4.1.17.p.2">In either case, the m= section index, MID, and ufrag fields from the supplied IceCandidate are used to determine which m= section and ICE candidate generation the IceCandidate belongs to, as described in <a href="#sec.ice-candidate-format" class="xref">Section 3.5.2.1</a> above. In the case of an end-of-candidates indication, the absence of both the m= section index and MID fields is interpreted to mean that the indication applies to all m= sections in the specified ICE candidate generation. However, if both fields are absent for a new remote candidate, this MUST be treated as an invalid condition, as specified below.</p>
<p id="rfc.section.4.1.17.p.3">If any IceCandidate fields contain invalid values, or an error occurs during the processing of the IceCandidate object, the supplied IceCandidate MUST be ignored and an error MUST be returned.</p>
<p id="rfc.section.4.1.17.p.4">Otherwise, the new remote candidate or end-of-candidates indication is supplied to the ICE agent. In the case of a new remote candidate, connectivity checks will be sent to the new candidate.</p>
<h2 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#sec.transceiver" id="sec.transceiver">RtpTransceiver</a>
</h2>
<h3 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#sec.transceiver-stop" id="sec.transceiver-stop">stop</a>
</h3>
<p id="rfc.section.4.2.1.p.1">The stop method stops an RtpTransceiver. This will cause future calls to createOffer to generate a zero port for the associated m= section. See below for more details.</p>
<h3 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#sec.transceiver-stopped" id="sec.transceiver-stopped">stopped</a>
</h3>
<p id="rfc.section.4.2.2.p.1">The stopped property indicates whether the transceiver has been stopped, either by a call to stopTransceiver or by applying an answer that rejects the associated m= section. In either of these cases, it is set to "true", and otherwise will be set to "false".</p>
<p id="rfc.section.4.2.2.p.2">A stopped RtpTransceiver does not send any outgoing RTP or RTCP or process any incoming RTP or RTCP. It cannot be restarted.</p>
<h3 id="rfc.section.4.2.3">
<a href="#rfc.section.4.2.3">4.2.3.</a> <a href="#sec.transceiver-set-direction" id="sec.transceiver-set-direction">setDirection</a>
</h3>
<p id="rfc.section.4.2.3.p.1">The setDirection method sets the direction of a transceiver, which affects the direction property of the associated m= section on future calls to createOffer and createAnswer. The permitted values for direction are "recvonly", "sendrecv", "sendonly", and "inactive", mirroring the identically-named directional attributes defined in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6.</p>
<p id="rfc.section.4.2.3.p.2">When creating offers, the transceiver direction is directly reflected in the output, even for re-offers. When creating answers, the transceiver direction is intersected with the offered direction, as explained in <a href="#sec.generating-an-answer" class="xref">Section 5.3</a> below.</p>
<p id="rfc.section.4.2.3.p.3">Note that while setDirection sets the direction property of the transceiver immediately ( <a href="#sec.transceiver-direction" class="xref">Section 4.2.4</a>), this property does not immediately affect whether the transceiver's RtpSender will send or its RtpReceiver will receive. The direction in effect is represented by the currentDirection property, which is only updated when an answer is applied.</p>
<h3 id="rfc.section.4.2.4">
<a href="#rfc.section.4.2.4">4.2.4.</a> <a href="#sec.transceiver-direction" id="sec.transceiver-direction">direction</a>
</h3>
<p id="rfc.section.4.2.4.p.1">The direction property indicates the last value passed into setDirection. If setDirection has never been called, it is set to the direction the transceiver was initialized with.</p>
<h3 id="rfc.section.4.2.5">
<a href="#rfc.section.4.2.5">4.2.5.</a> <a href="#sec.transceiver-current-direction" id="sec.transceiver-current-direction">currentDirection</a>
</h3>
<p id="rfc.section.4.2.5.p.1">The currentDirection property indicates the last negotiated direction for the transceiver's associated m= section. More specifically, it indicates the <a href="#RFC3264" class="xref">[RFC3264]</a> directional attribute of the associated m= section in the last applied answer (including provisional answers), with "send" and "recv" directions reversed if it was a remote answer. For example, if the directional attribute for the associated m= section in a remote answer is "recvonly", currentDirection is set to "sendonly".</p>
<p id="rfc.section.4.2.5.p.2">If an answer that references this transceiver has not yet been applied, or if the transceiver is stopped, currentDirection is set to null.</p>
<h3 id="rfc.section.4.2.6">
<a href="#rfc.section.4.2.6">4.2.6.</a> <a href="#sec.transceiver-set-codec-preferences" id="sec.transceiver-set-codec-preferences">setCodecPreferences</a>
</h3>
<p id="rfc.section.4.2.6.p.1">The setCodecPreferences method sets the codec preferences of a transceiver, which in turn affect the presence and order of codecs of the associated m= section on future calls to createOffer and createAnswer. Note that setCodecPreferences does not directly affect which codec the implementation decides to send. It only affects which codecs the implementation indicates that it prefers to receive, via the offer or answer. Even when a codec is excluded by setCodecPreferences, it still may be used to send until the next offer/answer exchange discards it.</p>
<p id="rfc.section.4.2.6.p.2">The codec preferences of an RtpTransceiver can cause codecs to be excluded by subsequent calls to createOffer and createAnswer, in which case the corresponding media formats in the associated m= section will be excluded. The codec preferences cannot add media formats that would otherwise not be present.</p>
<p id="rfc.section.4.2.6.p.3">The codec preferences of an RtpTransceiver can also determine the order of codecs in subsequent calls to createOffer and createAnswer, in which case the order of the media formats in the associated m= section will follow the specified preferences.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#sec.sdp-interaction-procedure" id="sec.sdp-interaction-procedure">SDP Interaction Procedures</a>
</h1>
<p id="rfc.section.5.p.1">This section describes the specific procedures to be followed when creating and parsing SDP objects.</p>
<h2 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#sec.requirements-overview" id="sec.requirements-overview">Requirements Overview</a>
</h2>
<p id="rfc.section.5.1.p.1">JSEP implementations must comply with the specifications listed below that govern the creation and processing of offers and answers.</p>
<h3 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#sec.usage-requirements" id="sec.usage-requirements">Usage Requirements</a>
</h3>
<p id="rfc.section.5.1.1.p.1">All session descriptions handled by JSEP implementations, both local and remote, MUST indicate support for the following specifications. If any of these are absent, this omission MUST be treated as an error.  </p>

<ul>
<li>ICE, as specified in <a href="#RFC8445" class="xref">[RFC8445]</a>, MUST be used. Note that the remote endpoint may use a Lite implementation; implementations MUST properly handle remote endpoints which do ICE-Lite.</li>
<li>DTLS <a href="#RFC6347" class="xref">[RFC6347]</a> or DTLS-SRTP <a href="#RFC5763" class="xref">[RFC5763]</a>, MUST be used, as appropriate for the media type, as specified in <a href="#I-D.ietf-rtcweb-security-arch" class="xref">[I-D.ietf-rtcweb-security-arch]</a>
</li>
</ul>
<p id="rfc.section.5.1.1.p.2">The SDES SRTP keying mechanism from <a href="#RFC4568" class="xref">[RFC4568]</a> MUST NOT be used, as discussed in <a href="#I-D.ietf-rtcweb-security-arch" class="xref">[I-D.ietf-rtcweb-security-arch]</a>.</p>
<h3 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#sec.profile-names" id="sec.profile-names">Profile Names and Interoperability</a>
</h3>
<p id="rfc.section.5.1.2.p.1">For media m= sections, JSEP implementations MUST support the "UDP/TLS/RTP/SAVPF" profile specified in <a href="#RFC5764" class="xref">[RFC5764]</a> as well as the "TCP/DTLS/RTP/SAVPF" profile specified in <a href="#RFC7850" class="xref">[RFC7850]</a>, and MUST indicate one of these profiles for each media m= line they produce in an offer.  For data m= sections, implementations MUST support the "UDP/DTLS/SCTP" profile as well as the "TCP/DTLS/SCTP" profile, and MUST indicate one of these profiles for each data m= line they produce in an offer. The exact profile to use is determined by the protocol associated with the current default or selected ICE candidate, as described in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.2.1.2.  </p>
<p id="rfc.section.5.1.2.p.2">Unfortunately, in an attempt at compatibility, some endpoints generate other profile strings even when they mean to support one of these profiles. For instance, an endpoint might generate "RTP/AVP" but supply "a=fingerprint" and "a=rtcp-fb" attributes, indicating its willingness to support "UDP/TLS/RTP/SAVPF" or "TCP/DTLS/RTP/SAVPF". In order to simplify compatibility with such endpoints, JSEP implementations MUST follow the following rules when processing the media m= sections in a received offer:</p>
<p></p>

<ul>
<li>Any profile in the offer matching one of the following MUST be accepted: <ul>
<li>"RTP/AVP" (Defined in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 8.2.2)</li>
<li>"RTP/AVPF" (Defined in <a href="#RFC4585" class="xref">[RFC4585]</a>, Section 9)</li>
<li>"RTP/SAVP" (Defined in <a href="#RFC3711" class="xref">[RFC3711]</a>, Section 12)</li>
<li>"RTP/SAVPF" (Defined in <a href="#RFC5124" class="xref">[RFC5124]</a>, Section 6)</li>
<li>"TCP/DTLS/RTP/SAVP" (Defined in <a href="#RFC7850" class="xref">[RFC7850]</a>, Section 3.4)</li>
<li>"TCP/DTLS/RTP/SAVPF" (Defined in <a href="#RFC7850" class="xref">[RFC7850]</a>, Section 3.5)</li>
<li>"UDP/TLS/RTP/SAVP" (Defined in <a href="#RFC5764" class="xref">[RFC5764]</a>, Section 9)</li>
<li>"UDP/TLS/RTP/SAVPF" (Defined in <a href="#RFC5764" class="xref">[RFC5764]</a>, Section 9)</li>
</ul>
</li>
<li>The profile in any "m=" line in any generated answer MUST exactly match the profile provided in the offer.</li>
<li>Because DTLS-SRTP is REQUIRED, the choice of SAVP or AVP has no effect; support for DTLS-SRTP is determined by the presence of one or more "a=fingerprint" attribute.  Note that lack of an "a=fingerprint" attribute will lead to negotiation failure.</li>
<li>The use of AVPF or AVP simply controls the timing rules used for RTCP feedback. If AVPF is provided, or an "a=rtcp-fb" attribute is present, assume AVPF timing, i.e., a default value of "trr-int=0". Otherwise, assume that AVPF is being used in an AVP compatible mode and use a value of "trr-int=4000".</li>
<li>For data m= sections, implementations MUST support receiving the "UDP/DTLS/SCTP", "TCP/DTLS/SCTP", or "DTLS/SCTP" (for backwards compatibility) profiles.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.2.p.4">Note that re-offers by JSEP implementations MUST use the correct profile strings even if the initial offer/answer exchange used an (incorrect) older profile string. This simplifies JSEP behavior, with minimal downside, as any remote endpoint that fails to handle such a re-offer will also fail to handle a JSEP endpoint's initial offer.</p>
<h2 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#sec-create-offer" id="sec-create-offer">Constructing an Offer</a>
</h2>
<p id="rfc.section.5.2.p.1">When createOffer is called, a new SDP description must be created that includes the functionality specified in <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>. The exact details of this process are explained below.</p>
<h3 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#sec.initial-offers" id="sec.initial-offers">Initial Offers</a>
</h3>
<p id="rfc.section.5.2.1.p.1">When createOffer is called for the first time, the result is known as the initial offer.</p>
<p id="rfc.section.5.2.1.p.2">The first step in generating an initial offer is to generate session-level attributes, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5. Specifically: </p>

<ul>
<li>The first SDP line MUST be "v=0", as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.1</li>
<li>The second SDP line MUST be an "o=" line, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.2. The value of the &lt;username&gt; field SHOULD be "-". The sess-id MUST be representable by a 64-bit signed integer, and the value MUST be less than (2**63)-1. It is RECOMMENDED that the sess-id be constructed by generating a 64-bit quantity with the highest bit set to zero and the remaining 63 bits being cryptographically random. The value of the &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt; tuple SHOULD be set to a non-meaningful address, such as IN IP4 0.0.0.0, to prevent leaking a local IP address in this field; this problem is discussed in <a href="#I-D.ietf-rtcweb-ip-handling" class="xref">[I-D.ietf-rtcweb-ip-handling]</a>. As mentioned in <a href="#RFC4566" class="xref">[RFC4566]</a>, the entire o= line needs to be unique, but selecting a random number for &lt;sess-id&gt; is sufficient to accomplish this.</li>
<li>The third SDP line MUST be a "s=" line, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.3; to match the "o=" line, a single dash SHOULD be used as the session name, e.g. "s=-". Note that this differs from the advice in <a href="#RFC4566" class="xref">[RFC4566]</a> which proposes a single space, but as both "o=" and "s=" are meaningless in JSEP, having the same meaningless value seems clearer.</li>
<li>Session Information ("i="), URI ("u="), Email Address ("e="), Phone Number ("p="), Repeat Times ("r="), and Time Zones ("z=") lines are not useful in this context and SHOULD NOT be included.</li>
<li>Encryption Keys ("k=") lines do not provide sufficient security and MUST NOT be included.</li>
<li>A "t=" line MUST be added, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.9; both &lt;start-time&gt; and &lt;stop-time&gt; SHOULD be set to zero, e.g. "t=0 0".</li>
<li>An "a=ice-options" line with the "trickle" and "ice2" options MUST be added, as specified in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 3 and <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 10.</li>
<li>If WebRTC identity is being used, an "a=identity" line as described in <a href="#I-D.ietf-rtcweb-security-arch" class="xref">[I-D.ietf-rtcweb-security-arch]</a>, Section 5.</li>
</ul>
<p id="rfc.section.5.2.1.p.3">The next step is to generate m= sections, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.14. An m= section is generated for each RtpTransceiver that has been added to the PeerConnection, excluding any stopped RtpTransceivers; this is done in the order the RtpTransceivers were added to the PeerConnection. If there are no such RtpTransceivers, no m= sections are generated; more can be added later, as discussed in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 5.</p>
<p id="rfc.section.5.2.1.p.4">For each m= section generated for an RtpTransceiver, establish a mapping between the transceiver and the index of the generated m= section.</p>
<p id="rfc.section.5.2.1.p.5">Each m= section, provided it is not marked as bundle-only, MUST generate a unique set of ICE credentials and gather its own unique set of ICE candidates. Bundle-only m= sections MUST NOT contain any ICE credentials and MUST NOT gather any candidates.</p>
<p id="rfc.section.5.2.1.p.6">For DTLS, all m= sections MUST use all the certificate(s) that have been specified for the PeerConnection; as a result, they MUST all have the same <a href="#RFC8122" class="xref">[RFC8122]</a> fingerprint value(s), or these value(s) MUST be session-level attributes.</p>
<p id="rfc.section.5.2.1.p.7">Each m= section should be generated as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.14. For the m= line itself, the following rules MUST be followed: </p>

<ul>
<li>If the m= section is marked as bundle-only, then the port value MUST be set to 0. Otherwise, the port value is set to the port of the default ICE candidate for this m= section, but given that no candidates are available yet, the "dummy" port value of 9 (Discard) MUST be used, as indicated in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 5.1.</li>
<li>To properly indicate use of DTLS, the &lt;proto&gt; field MUST be set to "UDP/TLS/RTP/SAVPF", as specified in <a href="#RFC5764" class="xref">[RFC5764]</a>, Section 8.</li>
<li>If codec preferences have been set for the associated transceiver, media formats MUST be generated in the corresponding order, and MUST exclude any codecs not present in the codec preferences.</li>
<li>Unless excluded by the above restrictions, the media formats MUST include the mandatory audio/video codecs as specified in <a href="#RFC7874" class="xref">[RFC7874]</a>, Section 3, and <a href="#RFC7742" class="xref">[RFC7742]</a>, Section 5.</li>
</ul>
<p id="rfc.section.5.2.1.p.8">The m= line MUST be followed immediately by a "c=" line, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.7. Again, as no candidates are available yet, the "c=" line must contain the "dummy" value "IN IP4 0.0.0.0", as defined in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 5.1.</p>
<p><a href="#I-D.ietf-mmusic-sdp-mux-attributes" class="xref">[I-D.ietf-mmusic-sdp-mux-attributes]</a> groups SDP attributes into different categories. To avoid unnecessary duplication when bundling, attributes of category IDENTICAL or TRANSPORT MUST NOT be repeated in bundled m= sections, repeating the guidance from <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 8.1. This includes m= sections for which bundling has been negotiated and is still desired, as well as m= sections marked as bundle-only.</p>
<p id="rfc.section.5.2.1.p.10">The following attributes, which are of a category other than IDENTICAL or TRANSPORT, MUST be included in each m= section:</p>
<p></p>

<ul>
<li>An "a=mid" line, as specified in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 4. All MID values MUST be generated in a fashion that does not leak user information, e.g., randomly or using a per-PeerConnection counter, and SHOULD be 3 bytes or less, to allow them to efficiently fit into the RTP header extension defined in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 14. Note that this does not set the RtpTransceiver mid property, as that only occurs when the description is applied. The generated MID value can be considered a "proposed" MID at this point.</li>
<li>A direction attribute which is the same as that of the associated transceiver.</li>
<li>For each media format on the m= line, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6, and <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 5.1.</li>
<li>For each primary codec where RTP retransmission should be used, a corresponding "a=rtpmap" line indicating "rtx" with the clock rate of the primary codec and an "a=fmtp" line that references the payload type of the primary codec, as specified in <a href="#RFC4588" class="xref">[RFC4588]</a>, Section 8.1.</li>
<li>For each supported FEC mechanism, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6. The FEC mechanisms that MUST be supported are specified in <a href="#I-D.ietf-rtcweb-fec" class="xref">[I-D.ietf-rtcweb-fec]</a>, Section 6, and specific usage for each media type is outlined in Sections 4 and 5.</li>
<li>If this m= section is for media with configurable durations of media per packet, e.g., audio, an "a=maxptime" line, indicating the maximum amount of media, specified in milliseconds, that can be encapsulated in each packet, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6. This value is set to the smallest of the maximum duration values across all the codecs included in the m= section.</li>
<li>If this m= section is for video media, and there are known limitations on the size of images which can be decoded, an "a=imageattr" line, as specified in <a href="#sec.imageattr" class="xref">Section 3.6</a>.</li>
<li>For each supported RTP header extension, an "a=extmap" line, as specified in <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 5. The list of header extensions that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.2. Any header extensions that require encryption MUST be specified as indicated in <a href="#RFC6904" class="xref">[RFC6904]</a>, Section 4.</li>
<li>For each supported RTCP feedback mechanism, an "a=rtcp-fb" line, as specified in <a href="#RFC4585" class="xref">[RFC4585]</a>, Section 4.2. The list of RTCP feedback mechanisms that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.1.</li>
<li>If the RtpTransceiver has a sendrecv or sendonly direction: <ul><li>For each MediaStream that was associated with the transceiver when it was created via addTrack or addTransceiver, an "a=msid" line, as specified in <a href="#I-D.ietf-mmusic-msid" class="xref">[I-D.ietf-mmusic-msid]</a>, Section 2, but omitting the "appdata" field.</li></ul>
</li>
<li>If the RtpTransceiver has a sendrecv or sendonly direction, and the application has specified RID values or has specified more than one encoding in the RtpSenders's parameters, an "a=rid" line for each encoding specified. The "a=rid" line is specified in <a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a>, and its direction MUST be "send". If the application has chosen a RID value, it MUST be used as the rid-identifier; otherwise a RID value MUST be generated by the implementation. RID values MUST be generated in a fashion that does not leak user information, e.g., randomly or using a per-PeerConnection counter, and SHOULD be 3 bytes or less, to allow them to efficiently fit into the RTP header extension defined in <a href="#I-D.ietf-avtext-rid" class="xref">[I-D.ietf-avtext-rid]</a>, Section 3. If no encodings have been specified, or only one encoding is specified but without a RID value, then no "a=rid" lines are generated.</li>
<li>If the RtpTransceiver has a sendrecv or sendonly direction and more than one "a=rid" line has been generated, an "a=simulcast" line, with direction "send", as defined in <a href="#I-D.ietf-mmusic-sdp-simulcast" class="xref">[I-D.ietf-mmusic-sdp-simulcast]</a>, Section 6.2. The list of RIDs MUST include all of the RID identifiers used in the "a=rid" lines for this m= section.</li>
<li>If the bundle policy for this PeerConnection is set to "max-bundle", and this is not the first m= section, or the bundle policy is set to "balanced", and this is not the first m= section for this media type, an "a=bundle-only" line.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.1.p.12">The following attributes, which are of category IDENTICAL or TRANSPORT, MUST appear only in "m=" sections which either have a unique address or which are associated with the bundle-tag. (In initial offers, this means those "m=" sections which do not contain an "a=bundle-only" attribute.)</p>
<p></p>

<ul>
<li>"a=ice-ufrag" and "a=ice-pwd" lines, as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4.</li>
<li>For each desired digest algorithm, one or more "a=fingerprint" lines for each of the endpoint's certificates, as specified in <a href="#RFC8122" class="xref">[RFC8122]</a>, Section 5.</li>
<li>An "a=setup" line, as specified in <a href="#RFC4145" class="xref">[RFC4145]</a>, Section 4, and clarified for use in DTLS-SRTP scenarios in <a href="#RFC5763" class="xref">[RFC5763]</a>, Section 5. The role value in the offer MUST be "actpass".</li>
<li>An "a=tls-id" line, as specified in <a href="#I-D.ietf-mmusic-dtls-sdp" class="xref">[I-D.ietf-mmusic-dtls-sdp]</a>, Section 5.2.</li>
<li>An "a=rtcp" line, as specified in <a href="#RFC3605" class="xref">[RFC3605]</a>, Section 2.1, containing the dummy value "9 IN IP4 0.0.0.0", because no candidates have yet been gathered.</li>
<li>An "a=rtcp-mux" line, as specified in <a href="#RFC5761" class="xref">[RFC5761]</a>, Section 5.1.3.</li>
<li>If the RTP/RTCP multiplexing policy is "require", an "a=rtcp-mux-only" line, as specified in <a href="#I-D.ietf-mmusic-mux-exclusive" class="xref">[I-D.ietf-mmusic-mux-exclusive]</a>, Section 4.</li>
<li>An "a=rtcp-rsize" line, as specified in <a href="#RFC5506" class="xref">[RFC5506]</a>, Section 5.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.1.p.14">Lastly, if a data channel has been created, a m= section MUST be generated for data. The &lt;media&gt; field MUST be set to "application" and the &lt;proto&gt; field MUST be set to "UDP/DTLS/SCTP" <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>. The "fmt" value MUST be set to "webrtc-datachannel" as specified in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 4.1.</p>
<p id="rfc.section.5.2.1.p.15">Within the data m= section, an "a=mid" line MUST be generated and included as described above, along with an "a=sctp-port" line referencing the SCTP port number, as defined in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 5.1, and, if appropriate, an "a=max-message-size" line, as defined in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 6.1.</p>
<p id="rfc.section.5.2.1.p.16">As discussed above, the following attributes of category IDENTICAL or TRANSPORT are included only if the data m= section either has a unique address or is associated with the bundle-tag (e.g., if it is the only m= section): </p>

<ul>
<li>"a=ice-ufrag"</li>
<li>"a=ice-pwd"</li>
<li>"a=fingerprint"</li>
<li>"a=setup"</li>
<li>"a=tls-id"</li>
</ul>
<p id="rfc.section.5.2.1.p.17">Once all m= sections have been generated, a session-level "a=group" attribute MUST be added as specified in <a href="#RFC5888" class="xref">[RFC5888]</a>. This attribute MUST have semantics "BUNDLE", and MUST include the mid identifiers of each m= section. The effect of this is that the JSEP implementation offers all m= sections as one bundle group.  However, whether the m= sections are bundle-only or not depends on the bundle policy.</p>
<p id="rfc.section.5.2.1.p.18">The next step is to generate session-level lip sync groups as defined in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 7. For each MediaStream referenced by more than one RtpTransceiver (by passing those MediaStreams as arguments to the addTrack and addTransceiver methods), a group of type "LS" MUST be added that contains the mid values for each RtpTransceiver.</p>
<p id="rfc.section.5.2.1.p.19">Attributes which SDP permits to either be at the session level or the media level SHOULD generally be at the media level even if they are identical. This assists development and debugging by making it easier to understand individual media sections, especially if one of a set of initially identical attributes is subsequently changed. However, implementations MAY choose to aggregate attributes at the session level and JSEP implementations MUST be prepared to receive attributes in either location.</p>
<p id="rfc.section.5.2.1.p.20">Attributes other than the ones specified above MAY be included, except for the following attributes which are specifically incompatible with the requirements of <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>, and MUST NOT be included: </p>

<ul>
<li>"a=crypto"</li>
<li>"a=key-mgmt"</li>
<li>"a=ice-lite"</li>
</ul>
<p id="rfc.section.5.2.1.p.21">Note that when bundle is used, any additional attributes that are added MUST follow the advice in <a href="#I-D.ietf-mmusic-sdp-mux-attributes" class="xref">[I-D.ietf-mmusic-sdp-mux-attributes]</a> on how those attributes interact with bundle.</p>
<p id="rfc.section.5.2.1.p.22">Note that these requirements are in some cases stricter than those of SDP. Implementations MUST be prepared to accept compliant SDP even if it would not conform to the requirements for generating SDP in this specification.</p>
<h3 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#sec.subsequent-offers" id="sec.subsequent-offers">Subsequent Offers</a>
</h3>
<p id="rfc.section.5.2.2.p.1">When createOffer is called a second (or later) time, or is called after a local description has already been installed, the processing is somewhat different than for an initial offer.</p>
<p id="rfc.section.5.2.2.p.2">If the previous offer was not applied using setLocalDescription, meaning the PeerConnection is still in the "stable" state, the steps for generating an initial offer should be followed, subject to the following restriction: </p>

<ul><li>The fields of the "o=" line MUST stay the same except for the &lt;session-version&gt; field, which MUST increment by one on each call to createOffer if the offer might differ from the output of the previous call to createOffer; implementations MAY opt to increment &lt;session-version&gt; on every call. The value of the generated &lt;session-version&gt; is independent of the &lt;session-version&gt; of the current local description; in particular, in the case where the current version is N, an offer is created and applied with version N+1, and then that offer is rolled back so that the current version is again N, the next generated offer will still have version N+2.</li></ul>
<p id="rfc.section.5.2.2.p.3">Note that if the application creates an offer by reading currentLocalDescription instead of calling createOffer, the returned SDP may be different than when setLocalDescription was originally called, due to the addition of gathered ICE candidates, but the &lt;session-version&gt; will not have changed. There are no known scenarios in which this causes problems, but if this is a concern, the solution is simply to use createOffer to ensure a unique &lt;session-version&gt;.</p>
<p id="rfc.section.5.2.2.p.4">If the previous offer was applied using setLocalDescription, but a corresponding answer from the remote side has not yet been applied, meaning the PeerConnection is still in the "have-local-offer" state, an offer is generated by following the steps in the "stable" state above, along with these exceptions: </p>

<ul>
<li>The "s=" and "t=" lines MUST stay the same.</li>
<li>If any RtpTransceiver has been added, and there exists an m= section with a zero port in the current local description or the current remote description, that m= section MUST be recycled by generating an m= section for the added RtpTransceiver as if the m= section were being added to the session description (including a new MID value), and placing it at the same index as the m= section with a zero port.</li>
<li>If an RtpTransceiver is stopped and is not associated with an m= section, an m= section MUST NOT be generated for it. This prevents adding back RtpTransceivers whose m= sections were recycled and used for a new RtpTransceiver in a previous offer/ answer exchange, as described above.</li>
<li>If an RtpTransceiver has been stopped and is associated with an m= section, and the m= section is not being recycled as described above, an m= section MUST be generated for it with the port set to zero and all "a=msid" lines removed.</li>
<li>For RtpTransceivers that are not stopped, the "a=msid" line(s) MUST stay the same if they are present in the current description, regardless of changes to the transceiver's direction or track. If no "a=msid" line is present in the current description, "a=msid" line(s) MUST be generated according to the same rules as for an initial offer.</li>
<li>Each "m=" and c=" line MUST be filled in with the port, relevant RTP profile, and address of the default candidate for the m= section, as described in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.2.1.2, and clarified in <a href="#sec.profile-names" class="xref">Section 5.1.2</a>.  If no RTP candidates have yet been gathered, dummy values MUST still be used, as described above.</li>
<li>Each "a=mid" line MUST stay the same.</li>
<li>Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same, unless the ICE configuration has changed (either changes to the supported STUN/TURN servers, or the ICE candidate policy), or the "IceRestart" option ( <a href="#sec.icerestart" class="xref">Section 5.2.3.1</a> was specified. If the m= section is bundled into another m= section, it still MUST NOT contain any ICE credentials.</li>
<li>If the m= section is not bundled into another m= section, its "a=rtcp" attribute line MUST be filled in with the port and address of the default RTCP candidate, as indicated in <a href="#RFC5761" class="xref">[RFC5761]</a>, Section 5.1.3. If no RTCP candidates have yet been gathered, dummy values MUST be used, as described in the initial offer section above.</li>
<li>If the m= section is not bundled into another m= section, for each candidate that has been gathered during the most recent gathering phase (see <a href="#sec.ice-gather-overview" class="xref">Section 3.5.1</a>), an "a=candidate" line MUST be added, as defined in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.1.  If candidate gathering for the section has completed, an "a=end-of-candidates" attribute MUST be added, as described in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 9.3.  If the m= section is bundled into another m= section, both "a=candidate" and "a=end-of-candidates" MUST be omitted.</li>
<li>For RtpTransceivers that are still present, the "a=rid" lines MUST stay the same.</li>
<li>For RtpTransceivers that are still present, any "a=simulcast" line MUST stay the same.</li>
</ul>
<p id="rfc.section.5.2.2.p.5">If the previous offer was applied using setLocalDescription, and a corresponding answer from the remote side has been applied using setRemoteDescription, meaning the PeerConnection is in the "have-remote-pranswer" or "stable" states, an offer is generated based on the negotiated session descriptions by following the steps mentioned for the "have-local-offer" state above.</p>
<p id="rfc.section.5.2.2.p.6">In addition, for each existing, non-recycled, non-rejected m= section in the new offer, the following adjustments are made based on the contents of the corresponding m= section in the current local or remote description, as appropriate: </p>

<ul>
<li>The m= line and corresponding "a=rtpmap" and "a=fmtp" lines MUST only include media formats which have not been excluded by the codec preferences of the associated transceiver, and MUST include all currently available formats. Media formats that were previously offered but are no longer available (e.g., a shared hardware codec) MAY be excluded.</li>
<li>Unless codec preferences have been set for the associated transceiver, the media formats on the m= line MUST be generated in the same order as in the most recent answer. Any media formats that were not present in the most recent answer MUST be added after all existing formats.</li>
<li>The RTP header extensions MUST only include those that are present in the most recent answer.</li>
<li>The RTCP feedback mechanisms MUST only include those that are present in the most recent answer, except for the case of format-specific mechanisms that are referencing a newly-added media format.</li>
<li>The "a=rtcp" line MUST NOT be added if the most recent answer included an "a=rtcp-mux" line.</li>
<li>The "a=rtcp-mux" line MUST be the same as that in the most recent answer.</li>
<li>The "a=rtcp-mux-only" line MUST NOT be added.</li>
<li>The "a=rtcp-rsize" line MUST NOT be added unless present in the most recent answer.</li>
<li>An "a=bundle-only" line MUST NOT be added, as indicated in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 6. Instead, JSEP implementations MUST simply omit parameters in the IDENTICAL and TRANSPORT categories for bundled m= sections, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 8.1.</li>
<li>Note that if media m= sections are bundled into a data m= section, then certain TRANSPORT and IDENTICAL attributes may appear in the data m= section even if they would otherwise only be appropriate for a media m= section (e.g., "a=rtcp-mux"). This cannot happen in initial offers because in the initial offer JSEP implementations always list media m= sections (if any) before the data m= section (if any), and at least one of those media m= sections will not have the "a=bundle-only" attribute. Therefore, in initial offers, any "a=bundle-only" m= sections will be bundled into a preceding non-bundle-only media m= section.</li>
</ul>
<p id="rfc.section.5.2.2.p.7">The "a=group:BUNDLE" attribute MUST include the MID identifiers specified in the bundle group in the most recent answer, minus any m= sections that have been marked as rejected, plus any newly added or re-enabled m= sections. In other words, the bundle attribute must contain all m= sections that were previously bundled, as long as they are still alive, as well as any new m= sections.</p>
<p id="rfc.section.5.2.2.p.8">"a=group:LS" attributes are generated in the same way as for initial offers, with the additional stipulation that any lip sync groups that were present in the most recent answer MUST continue to exist and MUST contain any previously existing MID identifiers, as long as the identified m= sections still exist and are not rejected, and the group still contains at least two MID identifiers. This ensures that any synchronized "recvonly" m= sections continue to be synchronized in the new offer.</p>
<h3 id="rfc.section.5.2.3">
<a href="#rfc.section.5.2.3">5.2.3.</a> <a href="#sec.options-handling1" id="sec.options-handling1">Options Handling</a>
</h3>
<p id="rfc.section.5.2.3.p.1">The createOffer method takes as a parameter an RTCOfferOptions object. Special processing is performed when generating a SDP description if the following options are present.</p>
<h4 id="rfc.section.5.2.3.1">
<a href="#rfc.section.5.2.3.1">5.2.3.1.</a> <a href="#sec.icerestart" id="sec.icerestart">IceRestart</a>
</h4>
<p id="rfc.section.5.2.3.1.p.1">If the "IceRestart" option is specified, with a value of "true", the offer MUST indicate an ICE restart by generating new ICE ufrag and pwd attributes, as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.4.1.1.1. If this option is specified on an initial offer, it has no effect (since a new ICE ufrag and pwd are already generated).  Similarly, if the ICE configuration has changed, this option has no effect, since new ufrag and pwd attributes will be generated automatically. This option is primarily useful for reestablishing connectivity in cases where failures are detected by the application.</p>
<h4 id="rfc.section.5.2.3.2">
<a href="#rfc.section.5.2.3.2">5.2.3.2.</a> <a href="#sec.voiceactivitydetection1" id="sec.voiceactivitydetection1">VoiceActivityDetection</a>
</h4>
<p id="rfc.section.5.2.3.2.p.1">Silence suppression, also known as discontinuous transmission ("DTX"), can reduce the bandwidth used for audio by switching to a special encoding when voice activity is not detected, at the cost of some fidelity.</p>
<p id="rfc.section.5.2.3.2.p.2">If the "VoiceActivityDetection" option is specified, with a value of "true", the offer MUST indicate support for silence suppression in the audio it receives by including comfort noise ("CN") codecs for each offered audio codec, as specified in <a href="#RFC3389" class="xref">[RFC3389]</a>, Section 5.1, except for codecs that have their own internal silence suppression support. For codecs that have their own internal silence suppression support, the appropriate fmtp parameters for that codec MUST be specified to indicate that silence suppression for received audio is desired. For example, when using the Opus codec <a href="#RFC6716" class="xref">[RFC6716]</a>, the "usedtx=1" parameter, specified in <a href="#RFC7587" class="xref">[RFC7587]</a>, would be used in the offer.</p>
<p id="rfc.section.5.2.3.2.p.3">If the "VoiceActivityDetection" option is specified, with a value of "false", the JSEP implementation MUST NOT emit "CN" codecs. For codecs that have their own internal silence suppression support, the appropriate fmtp parameters for that codec MUST be specified to indicate that silence suppression for received audio is not desired.  For example, when using the Opus codec, the "usedtx=0" parameter would be specified in the offer. In addition, the implementation MUST NOT use silence suppression for media it generates, regardless of whether the "CN" codecs or related fmtp parameters appear in the peer's description.  The impact of these rules is that silence suppression in JSEP depends on mutual agreement of both sides, which ensures consistent handling regardless of which codec is used.</p>
<p id="rfc.section.5.2.3.2.p.4">The "VoiceActivityDetection" option does not have any impact on the setting of the "vad" value in the signaling of the client to mixer audio level header extension described in <a href="#RFC6464" class="xref">[RFC6464]</a>, Section 4.</p>
<h2 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#sec.generating-an-answer" id="sec.generating-an-answer">Generating an Answer</a>
</h2>
<p id="rfc.section.5.3.p.1">When createAnswer is called, a new SDP description must be created that is compatible with the supplied remote description as well as the requirements specified in <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>. The exact details of this process are explained below.</p>
<h3 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#sec.initial-answers" id="sec.initial-answers">Initial Answers</a>
</h3>
<p id="rfc.section.5.3.1.p.1">When createAnswer is called for the first time after a remote description has been provided, the result is known as the initial answer. If no remote description has been installed, an answer cannot be generated, and an error MUST be returned.</p>
<p id="rfc.section.5.3.1.p.2">Note that the remote description SDP may not have been created by a JSEP endpoint and may not conform to all the requirements listed in <a href="#sec-create-offer" class="xref">Section 5.2</a>. For many cases, this is not a problem. However, if any mandatory SDP attributes are missing, or functionality listed as mandatory-to-use above is not present, this MUST be treated as an error, and MUST cause the affected m= sections to be marked as rejected.</p>
<p id="rfc.section.5.3.1.p.3">The first step in generating an initial answer is to generate session-level attributes. The process here is identical to that indicated in the initial offers section above, except that the "a=ice-options" line, with the "trickle" option as specified in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 3, and the "ice2" option as specified in <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 10, is only included if such an option was present in the offer.</p>
<p id="rfc.section.5.3.1.p.4">The next step is to generate session-level lip sync groups, as defined in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 7. For each group of type "LS" present in the offer, select the local RtpTransceivers that are referenced by the MID values in the specified group, and determine which of them either reference a common local MediaStream (specified in the calls to addTrack/addTransceiver used to create them), or have no MediaStream to reference because they were not created by addTrack/addTransceiver. If at least two such RtpTransceivers exist, a group of type "LS" with the mid values of these RtpTransceivers MUST be added. Otherwise the offered "LS" group MUST be ignored and no corresponding group generated in the answer.</p>
<p id="rfc.section.5.3.1.p.5">As a simple example, consider the following offer of a single audio and single video track contained in the same MediaStream. SDP lines not relevant to this example have been removed for clarity. As explained in <a href="#sec-create-offer" class="xref">Section 5.2</a>, a group of type "LS" has been added that references each track's RtpTransceiver.</p>
<pre>
                
          a=group:LS a1 v1
          m=audio 10000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=msid:ms1
          m=video 10001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=msid:ms1
                
</pre>
<p></p>
<p id="rfc.section.5.3.1.p.7">If the answerer uses a single MediaStream when it adds its tracks, both of its transceivers will reference this stream, and so the subsequent answer will contain a "LS" group identical to that in the offer, as shown below:</p>
<pre>
                
          a=group:LS a1 v1
          m=audio 20000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=msid:ms2
          m=video 20001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=msid:ms2
                
</pre>
<p></p>
<p id="rfc.section.5.3.1.p.9">However, if the answerer groups its tracks into separate MediaStreams, its transceivers will reference different streams, and so the subsequent answer will not contain a "LS" group.</p>
<pre>
                
          m=audio 20000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=msid:ms2a
          m=video 20001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=msid:ms2b
                
</pre>
<p></p>
<p id="rfc.section.5.3.1.p.11">Finally, if the answerer does not add any tracks, its transceivers will not reference any MediaStreams, causing the preferences of the offerer to be maintained, and so the subsequent answer will contain an identical "LS" group.</p>
<pre>
                
          a=group:LS a1 v1
          m=audio 20000 UDP/TLS/RTP/SAVPF 0
          a=mid:a1
          a=recvonly
          m=video 20001 UDP/TLS/RTP/SAVPF 96
          a=mid:v1
          a=recvonly
                
</pre>
<p></p>
<p id="rfc.section.5.3.1.p.13">The <a href="#sec.detailed-example" class="xref">Section 7.2</a> example later in this document shows a more involved case of "LS" group generation.</p>
<p id="rfc.section.5.3.1.p.14">The next step is to generate m= sections for each m= section that is present in the remote offer, as specified in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6. For the purposes of this discussion, any session-level attributes in the offer that are also valid as media-level attributes are considered to be present in each m= section. Each offered m= section will have an associated RtpTransceiver, as described in <a href="#sec.applying-a-remote-desc" class="xref">Section 5.10</a>. If there are more RtpTransceivers than there are m= sections, the unmatched RtpTransceivers will need to be associated in a subsequent offer.</p>
<p id="rfc.section.5.3.1.p.15">For each offered m= section, if any of the following conditions are true, the corresponding m= section in the answer MUST be marked as rejected by setting the port in the m= line to zero, as indicated in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6, and further processing for this m= section can be skipped: </p>

<ul>
<li>The associated RtpTransceiver has been stopped.</li>
<li>None of the offered media formats are supported and, if applicable, allowed by codec preferences.</li>
<li>The bundle policy is "max-bundle", and this is not the first m= section or in the same bundle group as the first m= section.</li>
<li>The bundle policy is "balanced", and this is not the first m= section for this media type or in the same bundle group as the first m= section for this media type.</li>
<li>This m= section is in a bundle group, and the group's offerer tagged m= section is being rejected due to one of the above reasons. This requires all m= sections in the bundle group to be rejected, as specified in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 7.3.3.</li>
</ul>
<p id="rfc.section.5.3.1.p.16">Otherwise, each m= section in the answer should then be generated as specified in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6.1. For the m= line itself, the following rules must be followed: </p>

<ul>
<li>The port value would normally be set to the port of the default ICE candidate for this m= section, but given that no candidates are available yet, the "dummy" port value of 9 (Discard) MUST be used, as indicated in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 5.1.</li>
<li>The &lt;proto&gt; field MUST be set to exactly match the &lt;proto&gt; field for the corresponding m= line in the offer.</li>
<li>If codec preferences have been set for the associated transceiver, media formats MUST be generated in the corresponding order, regardless of what was offered, and MUST exclude any codecs not present in the codec preferences.</li>
<li>Otherwise, the media formats on the m= line MUST be generated in the same order as those offered in the current remote description, excluding any currently unsupported formats. Any currently available media formats that are not present in the current remote description MUST be added after all existing formats.</li>
<li>In either case, the media formats in the answer MUST include at least one format that is present in the offer, but MAY include formats that are locally supported but not present in the offer, as mentioned in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6.1. If no common format exists, the m= section is rejected as described above.</li>
</ul>
<p id="rfc.section.5.3.1.p.17">The m= line MUST be followed immediately by a "c=" line, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.7. Again, as no candidates are available yet, the "c=" line must contain the "dummy" value "IN IP4 0.0.0.0", as defined in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 5.1.</p>
<p id="rfc.section.5.3.1.p.18">If the offer supports bundle, all m= sections to be bundled must use the same ICE credentials and candidates; all m= sections not being bundled must use unique ICE credentials and candidates. Each m= section MUST contain the following attributes (which are of attribute types other than IDENTICAL and TRANSPORT): </p>

<ul>
<li>If and only if present in the offer, an "a=mid" line, as specified in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 9.1. The "mid" value MUST match that specified in the offer.</li>
<li>A direction attribute, determined by applying the rules regarding the offered direction specified in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6.1, and then intersecting with the direction of the associated RtpTransceiver. For example, in the case where an m= section is offered as "sendonly", and the local transceiver is set to "sendrecv", the result in the answer is a "recvonly" direction.</li>
<li>For each media format on the m= line, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6, and <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6.1.</li>
<li>If "rtx" is present in the offer, for each primary codec where RTP retransmission should be used, a corresponding "a=rtpmap" line indicating "rtx" with the clock rate of the primary codec and an "a=fmtp" line that references the payload type of the primary codec, as specified in <a href="#RFC4588" class="xref">[RFC4588]</a>, Section 8.1.</li>
<li>For each supported FEC mechanism, "a=rtpmap" and "a=fmtp" lines, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6. The FEC mechanisms that MUST be supported are specified in <a href="#I-D.ietf-rtcweb-fec" class="xref">[I-D.ietf-rtcweb-fec]</a>, Section 6, and specific usage for each media type is outlined in Sections 4 and 5.</li>
<li>If this m= section is for media with configurable durations of media per packet, e.g., audio, an "a=maxptime" line, as described in <a href="#sec-create-offer" class="xref">Section 5.2</a>.</li>
<li>If this m= section is for video media, and there are known limitations on the size of images which can be decoded, an "a=imageattr" line, as specified in <a href="#sec.imageattr" class="xref">Section 3.6</a>.</li>
<li>For each supported RTP header extension that is present in the offer, an "a=extmap" line, as specified in <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 5. The list of header extensions that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.2. Any header extensions that require encryption MUST be specified as indicated in <a href="#RFC6904" class="xref">[RFC6904]</a>, Section 4.</li>
<li>For each supported RTCP feedback mechanism that is present in the offer, an "a=rtcp-fb" line, as specified in <a href="#RFC4585" class="xref">[RFC4585]</a>, Section 4.2. The list of RTCP feedback mechanisms that SHOULD/MUST be supported is specified in <a href="#I-D.ietf-rtcweb-rtp-usage" class="xref">[I-D.ietf-rtcweb-rtp-usage]</a>, Section 5.1.</li>
<li>If the RtpTransceiver has a sendrecv or sendonly direction: <ul><li>For each MediaStream that was associated with the transceiver when it was created via addTrack or addTransceiver, an "a=msid" line, as specified in <a href="#I-D.ietf-mmusic-msid" class="xref">[I-D.ietf-mmusic-msid]</a>, Section 2, but omitting the "appdata" field.</li></ul>
</li>
</ul>
<p id="rfc.section.5.3.1.p.19">Each m= section which is not bundled into another m= section, MUST contain the following attributes (which are of category IDENTICAL or TRANSPORT):</p>
<p></p>

<ul>
<li>"a=ice-ufrag" and "a=ice-pwd" lines, as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4.</li>
<li>For each desired digest algorithm, one or more "a=fingerprint" lines for each of the endpoint's certificates, as specified in <a href="#RFC8122" class="xref">[RFC8122]</a>, Section 5.</li>
<li>An "a=setup" line, as specified in <a href="#RFC4145" class="xref">[RFC4145]</a>, Section 4, and clarified for use in DTLS-SRTP scenarios in <a href="#RFC5763" class="xref">[RFC5763]</a>, Section 5. The role value in the answer MUST be "active" or "passive". When the offer contains the "actpass" value, as will always be the case with JSEP endpoints, the answerer SHOULD use the "active" role. Offers from non-JSEP endpoints MAY send other values for "a=setup", in which case the answer MUST use a value consistent with the value in the offer.</li>
<li>An "a=tls-id" line, as specified in <a href="#I-D.ietf-mmusic-dtls-sdp" class="xref">[I-D.ietf-mmusic-dtls-sdp]</a>, Section 5.3.</li>
<li>If present in the offer, an "a=rtcp-mux" line, as specified in <a href="#RFC5761" class="xref">[RFC5761]</a>, Section 5.1.3. Otherwise, an "a=rtcp" line, as specified in <a href="#RFC3605" class="xref">[RFC3605]</a>, Section 2.1, containing the dummy value "9 IN IP4 0.0.0.0" (because no candidates have yet been gathered).</li>
<li>If present in the offer, an "a=rtcp-rsize" line, as specified in <a href="#RFC5506" class="xref">[RFC5506]</a>, Section 5.</li>
</ul>

<p> </p>
<p id="rfc.section.5.3.1.p.21">If a data channel m= section has been offered, a m= section MUST also be generated for data. The &lt;media&gt; field MUST be set to "application" and the &lt;proto&gt; and &lt;fmt&gt; fields MUST be set to exactly match the fields in the offer.</p>
<p id="rfc.section.5.3.1.p.22">Within the data m= section, an "a=mid" line MUST be generated and included as described above, along with an "a=sctp-port" line referencing the SCTP port number, as defined in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 5.1, and, if appropriate, an "a=max-message-size" line, as defined in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 6.1.</p>
<p id="rfc.section.5.3.1.p.23">As discussed above, the following attributes of category IDENTICAL or TRANSPORT are included only if the data m= section is not bundled into another m= section: </p>

<ul>
<li>"a=ice-ufrag"</li>
<li>"a=ice-pwd"</li>
<li>"a=fingerprint"</li>
<li>"a=setup"</li>
<li>"a=tls-id"</li>
</ul>
<p id="rfc.section.5.3.1.p.24">Note that if media m= sections are bundled into a data m= section, then certain TRANSPORT and IDENTICAL attributes may also appear in the data m= section even if they would otherwise only be appropriate for a media m= section (e.g., "a=rtcp-mux").</p>
<p id="rfc.section.5.3.1.p.25">If "a=group" attributes with semantics of "BUNDLE" are offered, corresponding session-level "a=group" attributes MUST be added as specified in <a href="#RFC5888" class="xref">[RFC5888]</a>. These attributes MUST have semantics "BUNDLE", and MUST include the all mid identifiers from the offered bundle groups that have not been rejected.  Note that regardless of the presence of "a=bundle-only" in the offer, no m= sections in the answer should have an "a=bundle-only" line.</p>
<p id="rfc.section.5.3.1.p.26">Attributes that are common between all m= sections MAY be moved to session-level, if explicitly defined to be valid at session-level.</p>
<p id="rfc.section.5.3.1.p.27">The attributes prohibited in the creation of offers are also prohibited in the creation of answers.</p>
<h3 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#sec.subsequent-answers" id="sec.subsequent-answers">Subsequent Answers</a>
</h3>
<p id="rfc.section.5.3.2.p.1">When createAnswer is called a second (or later) time, or is called after a local description has already been installed, the processing is somewhat different than for an initial answer.</p>
<p id="rfc.section.5.3.2.p.2">If the previous answer was not applied using setLocalDescription, meaning the PeerConnection is still in the "have-remote-offer" state, the steps for generating an initial answer should be followed, subject to the following restriction: </p>

<ul><li>The fields of the "o=" line MUST stay the same except for the &lt;session-version&gt; field, which MUST increment if the session description changes in any way from the previously generated answer.</li></ul>
<p id="rfc.section.5.3.2.p.3">If any session description was previously supplied to setLocalDescription, an answer is generated by following the steps in the "have-remote-offer" state above, along with these exceptions: </p>

<ul>
<li>The "s=" and "t=" lines MUST stay the same.</li>
<li>Each "m=" and c=" line MUST be filled in with the port and address of the default candidate for the m= section, as described in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.2.1.2. Note that in certain cases, the m= line protocol may not match that of the default candidate, because the m= line protocol value MUST match what was supplied in the offer, as described above.</li>
<li>Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same, unless the m= section is restarting, in which case new ICE credentials must be created as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.4.1.1.1. If the m= section is bundled into another m= section, it still MUST NOT contain any ICE credentials.</li>
<li>Each "a=tls-id" line MUST stay the same unless the offerer's "a=tls-id" line changed, in which case a new "a=tls-id" value MUST be created, as described in <a href="#I-D.ietf-mmusic-dtls-sdp" class="xref">[I-D.ietf-mmusic-dtls-sdp]</a>, Section 5.2.</li>
<li>Each "a=setup" line MUST use an "active" or "passive" role value consistent with the existing DTLS association, if the association is being continued by the offerer.</li>
<li>RTCP multiplexing must be used, and an "a=rtcp-mux" line inserted if and only if the m= section previously used RTCP multiplexing.</li>
<li>If the m= section is not bundled into another m= section and RTCP multiplexing is not active, an "a=rtcp" attribute line MUST be filled in with the port and address of the default RTCP candidate. If no RTCP candidates have yet been gathered, dummy values MUST be used, as described in the initial answer section above.</li>
<li>If the m= section is not bundled into another m= section, for each candidate that has been gathered during the most recent gathering phase (see <a href="#sec.ice-gather-overview" class="xref">Section 3.5.1</a>), an "a=candidate" line MUST be added, as defined in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.1.  If candidate gathering for the section has completed, an "a=end-of-candidates" attribute MUST be added, as described in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 9.3.  If the m= section is bundled into another m= section, both "a=candidate" and "a=end-of-candidates" MUST be omitted.</li>
<li>For RtpTransceivers that are not stopped, the "a=msid" line(s) MUST stay the same, regardless of changes to the transceiver's direction or track. If no "a=msid" line is present in the current description, "a=msid" line(s) MUST be generated according to the same rules as for an initial answer.</li>
</ul>
<h3 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#sec.options-handling2" id="sec.options-handling2">Options Handling</a>
</h3>
<p id="rfc.section.5.3.3.p.1">The createAnswer method takes as a parameter an RTCAnswerOptions object. The set of parameters for RTCAnswerOptions is different than those supported in RTCOfferOptions; the IceRestart option is unnecessary, as ICE credentials will automatically be changed for all m= sections where the offerer chose to perform ICE restart.</p>
<p id="rfc.section.5.3.3.p.2">The following options are supported in RTCAnswerOptions.</p>
<h4 id="rfc.section.5.3.3.1">
<a href="#rfc.section.5.3.3.1">5.3.3.1.</a> <a href="#sec.voiceactivitydetection2" id="sec.voiceactivitydetection2">VoiceActivityDetection</a>
</h4>
<p id="rfc.section.5.3.3.1.p.1">Silence suppression in the answer is handled as described in <a href="#sec.voiceactivitydetection1" class="xref">Section 5.2.3.2</a>, with one exception: if support for silence suppression was not indicated in the offer, the VoiceActivityDetection parameter has no effect, and the answer should be generated as if VoiceActivityDetection was set to false. This is done on a per-codec basis (e.g., if the offerer somehow offered support for CN but set "usedtx=0" for Opus, setting VoiceActivityDetection to true would result in an answer with CN codecs and "usedtx=0"). The impact of this rule is that an answerer will not try to use silence suppression with any endpoint that does not offer it, making silence suppression support bilateral even with non-JSEP endpoints.</p>
<h2 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#sec.modifying-sdp" id="sec.modifying-sdp">Modifying an Offer or Answer</a>
</h2>
<p id="rfc.section.5.4.p.1">The SDP returned from createOffer or createAnswer MUST NOT be changed before passing it to setLocalDescription. If precise control over the SDP is needed, the aforementioned createOffer/createAnswer options or RtpTransceiver APIs MUST be used.</p>
<p id="rfc.section.5.4.p.2">After calling setLocalDescription with an offer or answer, the application MAY modify the SDP to reduce its capabilities before sending it to the far side, as long as it follows the rules above that define a valid JSEP offer or answer. Likewise, an application that has received an offer or answer from a peer MAY modify the received SDP, subject to the same constraints, before calling setRemoteDescription.</p>
<p id="rfc.section.5.4.p.3">As always, the application is solely responsible for what it sends to the other party, and all incoming SDP will be processed by the JSEP implementation to the extent of its capabilities. It is an error to assume that all SDP is well-formed; however, one should be able to assume that any implementation of this specification will be able to process, as a remote offer or answer, unmodified SDP coming from any other implementation of this specification.</p>
<h2 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#sec.processing-a-local-desc" id="sec.processing-a-local-desc">Processing a Local Description</a>
</h2>
<p id="rfc.section.5.5.p.1">When a SessionDescription is supplied to setLocalDescription, the following steps MUST be performed: </p>

<ul>
<li>If the description is of type "rollback", follow the processing defined in <a href="#sec.processing-a-rollback" class="xref">Section 5.7</a> and skip the processing described in the rest of this section.</li>
<li>Otherwise, the type of the SessionDescription is checked against the current state of the PeerConnection: <ul>
<li>If the type is "offer", the PeerConnection state MUST be either "stable" or "have-local-offer".</li>
<li>If the type is "pranswer" or "answer", the PeerConnection state MUST be either "have-remote-offer" or "have-local-pranswer".</li>
</ul>
</li>
<li>If the type is not correct for the current state, processing MUST stop and an error MUST be returned.</li>
<li>The SessionDescription is then checked to ensure that its contents are identical to those generated in the last call to createOffer/createAnswer, and thus have not been altered, as discussed in <a href="#sec.modifying-sdp" class="xref">Section 5.4</a>; otherwise, processing MUST stop and an error MUST be returned.</li>
<li>Next, the SessionDescription is parsed into a data structure, as described in <a href="#sec.parsing-a-desc" class="xref">Section 5.8</a> below.</li>
<li>Finally, the parsed SessionDescription is applied as described in <a href="#sec.applying-a-local-desc" class="xref">Section 5.9</a> below.</li>
</ul>
<h2 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#sec.processing-a-remote-desc" id="sec.processing-a-remote-desc">Processing a Remote Description</a>
</h2>
<p id="rfc.section.5.6.p.1">When a SessionDescription is supplied to setRemoteDescription, the following steps MUST be performed: </p>

<ul>
<li>If the description is of type "rollback", follow the processing defined in <a href="#sec.processing-a-rollback" class="xref">Section 5.7</a> and skip the processing described in the rest of this section.</li>
<li>Otherwise, the type of the SessionDescription is checked against the current state of the PeerConnection: <ul>
<li>If the type is "offer", the PeerConnection state MUST be either "stable" or "have-remote-offer".</li>
<li>If the type is "pranswer" or "answer", the PeerConnection state MUST be either "have-local-offer" or "have-remote-pranswer".</li>
</ul>
</li>
<li>If the type is not correct for the current state, processing MUST stop and an error MUST be returned.</li>
<li>Next, the SessionDescription is parsed into a data structure, as described in <a href="#sec.parsing-a-desc" class="xref">Section 5.8</a> below. If parsing fails for any reason, processing MUST stop and an error MUST be returned.</li>
<li>Finally, the parsed SessionDescription is applied as described in <a href="#sec.applying-a-remote-desc" class="xref">Section 5.10</a> below.</li>
</ul>
<h2 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> <a href="#sec.processing-a-rollback" id="sec.processing-a-rollback">Processing a Rollback</a>
</h2>
<p id="rfc.section.5.7.p.1">A rollback may be performed if the PeerConnection is in any state except for "stable". This means that both offers and provisional answers can be rolled back. Rollback can only be used to cancel proposed changes; there is no support for rolling back from a stable state to a previous stable state. If a rollback is attempted in the "stable" state, processing MUST stop and an error MUST be returned. Note that this implies that once the answerer has performed setLocalDescription with his answer, this cannot be rolled back.</p>
<p id="rfc.section.5.7.p.2">The effect of rollback MUST be the same regardless of whether setLocalDescription or setRemoteDescription is called.</p>
<p id="rfc.section.5.7.p.3">In order to process rollback, a JSEP implementation abandons the current offer/answer transaction, sets the signaling state to "stable", and sets the pending local and/or remote description (see <a href="#sec.pendinglocaldescription" class="xref">Section 4.1.12</a> and <a href="#sec.pendingremotedescription" class="xref">Section 4.1.14</a>) to null. Any resources or candidates that were allocated by the abandoned local description are discarded; any media that is received is processed according to the previous local and remote descriptions.</p>
<p id="rfc.section.5.7.p.4">A rollback disassociates any RtpTransceivers that were associated with m= sections by the application of the rolled-back session description (see <a href="#sec.applying-a-remote-desc" class="xref">Section 5.10</a> and <a href="#sec.applying-a-local-desc" class="xref">Section 5.9</a>). This means that some RtpTransceivers that were previously associated will no longer be associated with any m= section; in such cases, the value of the RtpTransceiver's mid property MUST be set to null, and the mapping between the transceiver and its m= section index MUST be discarded. RtpTransceivers that were created by applying a remote offer that was subsequently rolled back MUST be stopped and removed from the PeerConnection. However, a RtpTransceiver MUST NOT be removed if a track was attached to the RtpTransceiver via the addTrack method. This is so that an application may call addTrack, then call setRemoteDescription with an offer, then roll back that offer, then call createOffer and have a m= section for the added track appear in the generated offer.</p>
<h2 id="rfc.section.5.8">
<a href="#rfc.section.5.8">5.8.</a> <a href="#sec.parsing-a-desc" id="sec.parsing-a-desc">Parsing a Session Description</a>
</h2>
<p id="rfc.section.5.8.p.1">The SDP contained in the session description object consists of a sequence of text lines, each containing a key-value expression, as described in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5. The SDP is read, line-by-line, and converted to a data structure that contains the deserialized information. However, SDP allows many types of lines, not all of which are relevant to JSEP applications. For each line, the implementation will first ensure it is syntactically correct according to its defining ABNF, check that it conforms to <a href="#RFC4566" class="xref">[RFC4566]</a> and <a href="#RFC3264" class="xref">[RFC3264]</a> semantics, and then either parse and store or discard the provided value, as described below.</p>
<p id="rfc.section.5.8.p.2">If any line is not well-formed, or cannot be parsed as described, the parser MUST stop with an error and reject the session description, even if the value is to be discarded. This ensures that implementations do not accidentally misinterpret ambiguous SDP.</p>
<h3 id="rfc.section.5.8.1">
<a href="#rfc.section.5.8.1">5.8.1.</a> <a href="#sec.session-level-parse" id="sec.session-level-parse">Session-Level Parsing</a>
</h3>
<p id="rfc.section.5.8.1.p.1">First, the session-level lines are checked and parsed.  These lines MUST occur in a specific order, and with a specific syntax, as defined in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5. Note that while the specific line types (e.g. "v=", "c=") MUST occur in the defined order, lines of the same type (typically "a=") can occur in any order.</p>
<p id="rfc.section.5.8.1.p.2">The following non-attribute lines are not meaningful in the JSEP context and MAY be discarded once they have been checked.  </p>

<ul class="empty">
<li>The "c=" line MUST be checked for syntax but its value is only used for ICE mismatch detection, as defined in <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 5.4. Note that JSEP implementations should never encounter this condition because ICE is required for WebRTC.</li>
<li>The "i=", "u=", "e=", "p=", "t=", "r=", "z=", and "k=" lines are not used by this specification; they MUST be checked for syntax but their values are not used.</li>
</ul>
<p id="rfc.section.5.8.1.p.3">The remaining non-attribute lines are processed as follows: </p>

<ul class="empty">
<li>The "v=" line MUST have a version of 0, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.1.</li>
<li>The "o=" line MUST be parsed as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.2.</li>
<li>The "b=" line, if present, MUST be parsed as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.8, and the bwtype and bandwidth values stored.</li>
</ul>
<p id="rfc.section.5.8.1.p.4">Finally, the attribute lines are processed. Specific processing MUST be applied for the following session-level attribute ("a=") lines: </p>

<ul>
<li>Any "a=group" lines are parsed as specified in <a href="#RFC5888" class="xref">[RFC5888]</a>, Section 5, and the group's semantics and mids are stored.</li>
<li>If present, a single "a=ice-lite" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.3, and a value indicating the presence of ice-lite is stored.</li>
<li>If present, a single "a=ice-ufrag" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4, and the ufrag value is stored.</li>
<li>If present, a single "a=ice-pwd" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4, and the password value is stored.</li>
<li>If present, a single "a=ice-options" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.6, and the set of specified options is stored.</li>
<li>Any "a=fingerprint" lines are parsed as specified in <a href="#RFC8122" class="xref">[RFC8122]</a>, Section 5, and the set of fingerprint and algorithm values is stored.</li>
<li>If present, a single "a=setup" line is parsed as specified in <a href="#RFC4145" class="xref">[RFC4145]</a>, Section 4, and the setup value is stored.</li>
<li>If present, a single "a=tls-id" line is parsed as specified in <a href="#I-D.ietf-mmusic-dtls-sdp" class="xref">[I-D.ietf-mmusic-dtls-sdp]</a> Section 5, and the tls-id value is stored.</li>
<li>Any "a=identity" lines are parsed and the identity values stored for subsequent verification, as specified <a href="#I-D.ietf-rtcweb-security-arch" class="xref">[I-D.ietf-rtcweb-security-arch]</a>, Section 5.</li>
<li>Any "a=extmap" lines are parsed as specified in <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 5, and their values are stored.</li>
</ul>
<p id="rfc.section.5.8.1.p.5">Other attributes that are not relevant to JSEP may also be present, and implementations SHOULD process any that they recognize. As required by <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.13, unknown attribute lines MUST be ignored.</p>
<p id="rfc.section.5.8.1.p.6">Once all the session-level lines have been parsed, processing continues with the lines in m= sections.</p>
<h3 id="rfc.section.5.8.2">
<a href="#rfc.section.5.8.2">5.8.2.</a> <a href="#sec.media-level-parse" id="sec.media-level-parse">Media Section Parsing</a>
</h3>
<p id="rfc.section.5.8.2.p.1">Like the session-level lines, the media section lines MUST occur in the specific order and with the specific syntax defined in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.</p>
<p id="rfc.section.5.8.2.p.2">The "m=" line itself MUST be parsed as described in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.14, and the media, port, proto, and fmt values stored.</p>
<p id="rfc.section.5.8.2.p.3">Following the "m=" line, specific processing MUST be applied for the following non-attribute lines: </p>

<ul>
<li>As with the "c=" line at the session level, the "c=" line MUST be parsed according to <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.7, but its value is not used.</li>
<li>The "b=" line, if present, MUST be parsed as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.8, and the bwtype and bandwidth values stored.</li>
</ul>
<p id="rfc.section.5.8.2.p.4">Specific processing MUST also be applied for the following attribute lines: </p>

<ul>
<li>If present, a single "a=ice-ufrag" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4, and the ufrag value is stored.</li>
<li>If present, a single "a=ice-pwd" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4, and the password value is stored.</li>
<li>If present, a single "a=ice-options" line is parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.6, and the set of specified options is stored.</li>
<li>Any "a=candidate" attributes MUST be parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.1, and their values stored.</li>
<li>Any "a=remote-candidates" attributes MUST be parsed as specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.2, but their values are ignored.</li>
<li>If present, a single "a=end-of-candidates" attribute MUST be parsed as specified in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 8.2, and its presence or absence flagged and stored.</li>
<li>Any "a=fingerprint" lines are parsed as specified in <a href="#RFC8122" class="xref">[RFC8122]</a>, Section 5, and the set of fingerprint and algorithm values is stored.</li>
</ul>
<p id="rfc.section.5.8.2.p.5">If the "m=" proto value indicates use of RTP, as described in <a href="#sec.profile-names" class="xref">Section 5.1.2</a> above, the following attribute lines MUST be processed: </p>

<ul>
<li>The "m=" fmt value MUST be parsed as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.14, and the individual values stored.</li>
<li>Any "a=rtpmap" or "a=fmtp" lines MUST be parsed as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6, and their values stored.</li>
<li>If present, a single "a=ptime" line MUST be parsed as described in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6, and its value stored.</li>
<li>If present, a single "a=maxptime" line MUST be parsed as described in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6, and its value stored.</li>
<li>If present, a single direction attribute line (e.g.  "a=sendrecv") MUST be parsed as described in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 6, and its value stored.</li>
<li>Any "a=ssrc" attributes MUST be parsed as specified in <a href="#RFC5576" class="xref">[RFC5576]</a>, Section 4.1, and their values stored.</li>
<li>Any "a=extmap" attributes MUST be parsed as specified in <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 5, and their values stored.</li>
<li>Any "a=rtcp-fb" attributes MUST be parsed as specified in <a href="#RFC4585" class="xref">[RFC4585]</a>, Section 4.2., and their values stored.</li>
<li>If present, a single "a=rtcp-mux" attribute MUST be parsed as specified in <a href="#RFC5761" class="xref">[RFC5761]</a>, Section 5.1.3, and its presence or absence flagged and stored.</li>
<li>If present, a single "a=rtcp-mux-only" attribute MUST be parsed as specified in <a href="#I-D.ietf-mmusic-mux-exclusive" class="xref">[I-D.ietf-mmusic-mux-exclusive]</a>, Section 3, and its presence or absence flagged and stored.</li>
<li>If present, a single "a=rtcp-rsize" attribute MUST be parsed as specified in <a href="#RFC5506" class="xref">[RFC5506]</a>, Section 5, and its presence or absence flagged and stored.</li>
<li>If present, a single "a=rtcp" attribute MUST be parsed as specified in <a href="#RFC3605" class="xref">[RFC3605]</a>, Section 2.1, but its value is ignored, as this information is superfluous when using ICE.</li>
<li>If present, "a=msid" attributes MUST be parsed as specified in <a href="#I-D.ietf-mmusic-msid" class="xref">[I-D.ietf-mmusic-msid]</a>, Section 3.2, and their values stored, ignoring any "appdata" field. If no "a=msid" attributes are present, a random msid-id value is generated for a "default" MediaStream for the session, if not already present, and this value is stored.</li>
<li>Any "a=imageattr" attributes MUST be parsed as specified in <a href="#RFC6236" class="xref">[RFC6236]</a>, Section 3, and their values stored.</li>
<li>Any "a=rid" lines MUST be parsed as specified in <a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a>, Section 10, and their values stored.</li>
<li>If present, a single "a=simulcast" line MUST be parsed as specified in <a href="#I-D.ietf-mmusic-sdp-simulcast" class="xref">[I-D.ietf-mmusic-sdp-simulcast]</a>, and its values stored.</li>
</ul>
<p id="rfc.section.5.8.2.p.6">Otherwise, if the "m=" proto value indicates use of SCTP, the following attribute lines MUST be processed: </p>

<ul>
<li>The "m=" fmt value MUST be parsed as specified in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 4.3, and the application protocol value stored.</li>
<li>An "a=sctp-port" attribute MUST be present, and it MUST be parsed as specified in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 5.2, and the value stored.</li>
<li>If present, a single "a=max-message-size" attribute MUST be parsed as specified in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 6, and the value stored. Otherwise, use the specified default.</li>
</ul>
<p id="rfc.section.5.8.2.p.7">Other attributes that are not relevant to JSEP may also be present, and implementations SHOULD process any that they recognize. As required by <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.13, unknown attribute lines MUST be ignored.</p>
<h3 id="rfc.section.5.8.3">
<a href="#rfc.section.5.8.3">5.8.3.</a> Semantics Verification</h3>
<p id="rfc.section.5.8.3.p.1">Assuming parsing completes successfully, the parsed description is then evaluated to ensure internal consistency as well as proper support for mandatory features.  Specifically, the following checks are performed: </p>

<ul>
<li>For each m= section, valid values for each of the mandatory-to-use features enumerated in <a href="#sec.usage-requirements" class="xref">Section 5.1.1</a> MUST be present.  These values MAY either be present at the media level, or inherited from the session level.  <ul>
<li>ICE ufrag and password values, which MUST comply with the size limits specified in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 4.4.</li>
<li>tls-id value, which MUST be set according to <a href="#I-D.ietf-mmusic-dtls-sdp" class="xref">[I-D.ietf-mmusic-dtls-sdp]</a>, Section 5. If this is a re-offer or a response to a re-offer and the tls-id value is different from that presently in use, the DTLS connection is not being continued and the remote description MUST be part of an ICE restart, together with new ufrag and password values.</li>
<li>DTLS setup value, which MUST be set according to the rules specified in <a href="#RFC5763" class="xref">[RFC5763]</a>, Section 5 and MUST be consistent with the selected role of the current DTLS connection, if one exists and is being continued.</li>
<li>DTLS fingerprint values, where at least one fingerprint MUST be present.</li>
</ul>
</li>
<li>All RID values referenced in an "a=simulcast" line MUST exist as "a=rid" lines.</li>
<li>Each m= section is also checked to ensure prohibited features are not used.</li>
<li>If the RTP/RTCP multiplexing policy is "require", each m= section MUST contain an "a=rtcp-mux" attribute. If an m= section contains an "a=rtcp-mux-only" attribute, that section MUST also contain an "a=rtcp-mux" attribute.</li>
<li>If an m= section was present in the previous answer, the state of RTP/RTCP multiplexing MUST match what was previously negotiated.</li>
</ul>
<p id="rfc.section.5.8.3.p.2">If this session description is of type "pranswer" or "answer", the following additional checks are applied: </p>

<ul>
<li>The session description must follow the rules defined in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6, including the requirement that the number of m= sections MUST exactly match the number of m= sections in the associated offer.</li>
<li>For each m= section, the media type and protocol values MUST exactly match the media type and protocol values in the corresponding m= section in the associated offer.</li>
</ul>
<p id="rfc.section.5.8.3.p.3">If any of the preceding checks failed, processing MUST stop and an error MUST be returned.</p>
<h2 id="rfc.section.5.9">
<a href="#rfc.section.5.9">5.9.</a> <a href="#sec.applying-a-local-desc" id="sec.applying-a-local-desc">Applying a Local Description</a>
</h2>
<p id="rfc.section.5.9.p.1">The following steps are performed at the media engine level to apply a local description. If an error is returned, the session MUST be restored to the state it was in before performing these steps.</p>
<p id="rfc.section.5.9.p.2">First, m= sections are processed. For each m= section, the following steps MUST be performed; if any parameters are out of bounds, or cannot be applied, processing MUST stop and an error MUST be returned.  </p>

<ul>
<li>If this m= section is new, begin gathering candidates for it, as defined in <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 5.1.1, unless it is definitively being bundled (either this is an offer and the m= section is marked bundle-only, or it is an answer and the m= section is bundled into into another m= section.)</li>
<li>Or, if the ICE ufrag and password values have changed, trigger the ICE agent to start an ICE restart as described in <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 9, and begin gathering new candidates for the m= section. If this description is an answer, also start checks on that media section.</li>
<li>If the m= section proto value indicates use of RTP: <ul>
<li>If there is no RtpTransceiver associated with this m= section, find one and associate it with this m= section according to the following steps. Note that this situation will only occur when applying an offer.  <ul>
<li>Find the RtpTransceiver that corresponds to this m= section, using the mapping between transceivers and m= section indices established when creating the offer.</li>
<li>Set the value of this RtpTransceiver's mid property to the MID of the m= section.</li>
</ul>
</li>
<li>If RTCP mux is indicated, prepare to demux RTP and RTCP from the RTP ICE component, as specified in <a href="#RFC5761" class="xref">[RFC5761]</a>, Section 5.1.3.</li>
<li>For each specified RTP header extension, establish a mapping between the extension ID and URI, as described in <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 6.</li>
<li>If the MID header extension is supported, prepare to demux RTP streams intended for this m= section based on the MID header extension, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 15.</li>
<li>For each specified media format, establish a mapping between the payload type and the actual media format, as described in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6.1. In addition, prepare to demux RTP streams intended for this m= section based on the media formats supported by this m= section, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 10.2.</li>
<li>For each specified "rtx" media format, establish a mapping between the RTX payload type and its associated primary payload type, as described in <a href="#RFC4588" class="xref">[RFC4588]</a>, Sections 8.6 and 8.7.</li>
<li>If the directional attribute is of type "sendrecv" or "recvonly", enable receipt and decoding of media.</li>
</ul>
</li>
</ul>
<p id="rfc.section.5.9.p.3">Finally, if this description is of type "pranswer" or "answer", follow the processing defined in <a href="#sec.applying-an-answer" class="xref">Section 5.11</a> below.</p>
<h2 id="rfc.section.5.10">
<a href="#rfc.section.5.10">5.10.</a> <a href="#sec.applying-a-remote-desc" id="sec.applying-a-remote-desc">Applying a Remote Description</a>
</h2>
<p id="rfc.section.5.10.p.1">The following steps are performed to apply a remote description. If an error is returned, the session MUST be restored to the state it was in before performing these steps.</p>
<p id="rfc.section.5.10.p.2">If the answer contains any "a=ice-options" attributes where "trickle" is listed as an attribute, update the PeerConnection canTrickle property to be true. Otherwise, set this property to false.</p>
<p id="rfc.section.5.10.p.3">The following steps MUST be performed for attributes at the session level; if any parameters are out of bounds, or cannot be applied, processing MUST stop and an error MUST be returned.  </p>

<ul>
<li>For any specified "CT" bandwidth value, set this as the limit for the maximum total bitrate for all m= sections, as specified in <a href="#RFC4566" class="xref">[RFC4566]</a>, Section 5.8. Within this overall limit, the implementation can dynamically decide how to best allocate the available bandwidth between m= sections, respecting any specific limits that have been specified for individual m= sections.</li>
<li>For any specified "RR" or "RS" bandwidth values, handle as specified in <a href="#RFC3556" class="xref">[RFC3556]</a>, Section 2.</li>
<li>Any "AS" bandwidth value MUST be ignored, as the meaning of this construct at the session level is not well defined.</li>
</ul>
<p id="rfc.section.5.10.p.4">For each m= section, the following steps MUST be performed; if any parameters are out of bounds, or cannot be applied, processing MUST stop and an error MUST be returned.  </p>

<ul>
<li>If the ICE ufrag or password changed from the previous remote description: <ul>
<li>If the description is of type "offer", the implementation MUST note that an ICE restart is needed, as described in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.4.1.1.1</li>
<li>If the description is of type "answer" or "pranswer", then check to see if the current local description is an ICE restart, and if not, generate an error. If the PeerConnection state is "have-remote-pranswer", and the ICE ufrag or password changed from the previous provisional answer, then signal the ICE agent to discard any previous ICE check list state for the m= section. Finally, signal the ICE agent to begin checks.</li>
</ul>
</li>
<li>If the current local description indicates an ICE restart, and either the ICE ufrag or password has not changed from the previous remote description, as prescribed by <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 9, generate an error.</li>
<li>Configure the ICE components associated with this media section to use the supplied ICE remote ufrag and password for their connectivity checks.</li>
<li>Pair any supplied ICE candidates with any gathered local candidates, as described in <a href="#RFC8445" class="xref">[RFC8445]</a>, Section 6.1.2, and start connectivity checks with the appropriate credentials.</li>
<li>If an "a=end-of-candidates" attribute is present, process the end-of-candidates indication as described in <a href="#I-D.ietf-ice-trickle" class="xref">[I-D.ietf-ice-trickle]</a>, Section 11.</li>
<li>If the m= section proto value indicates use of RTP: <ul>
<li>If the m= section is being recycled (see <a href="#sec.subsequent-offers" class="xref">Section 5.2.2</a>), dissociate the currently associated RtpTransceiver by setting its mid property to null, and discard the mapping between the transceiver and its m= section index.</li>
<li>If the m= section is not associated with any RtpTransceiver (possibly because it was dissociated in the previous step), either find an RtpTransceiver or create one according to the following steps: <ul>
<li>If the m= section is sendrecv or recvonly, and there are RtpTransceivers of the same type that were added to the PeerConnection by addTrack and are not associated with any m= section and are not stopped, find the first (according to the canonical order described in <a href="#sec.initial-offers" class="xref">Section 5.2.1</a>) such RtpTransceiver.</li>
<li>If no RtpTransceiver was found in the previous step, create one with a recvonly direction.</li>
<li>Associate the found or created RtpTransceiver with the m= section by setting the value of the RtpTransceiver's mid property to the MID of the m= section, and establish a mapping between the transceiver and the index of the m= section. If the m= section does not include a MID (i.e., the remote endpoint does not support the MID extension), generate a value for the RtpTransceiver mid property, following the guidance for "a=mid" mentioned in <a href="#sec.initial-offers" class="xref">Section 5.2.1</a>.</li>
</ul>
</li>
<li>For each specified media format that is also supported by the local implementation, establish a mapping between the specified payload type and the media format, as described in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 6.1. Specifically, this means that the implementation records the payload type to be used in outgoing RTP packets when sending each specified media format, as well as the relative preference for each format that is indicated in their ordering. If any indicated media format is not supported by the local implementation, it MUST be ignored.</li>
<li>For each specified "rtx" media format, establish a mapping between the RTX payload type and its associated primary payload type, as described in <a href="#RFC4588" class="xref">[RFC4588]</a>, Section 4. If any referenced primary payload types are not present, this MUST result in an error. Note that RTX payload types may refer to primary payload types which are not supported by the local media implementation, in which case, the RTX payload type MUST also be ignored.</li>
<li>For each specified fmtp parameter that is supported by the local implementation, enable them on the associated media formats.</li>
<li>For each specified SSRC that is signaled in the m= section, prepare to demux RTP streams intended for this m= section using that SSRC, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 10.2.</li>
<li>For each specified RTP header extension that is also supported by the local implementation, establish a mapping between the extension ID and URI, as described in <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 5. Specifically, this means that the implementation records the extension ID to be used in outgoing RTP packets when sending each specified header extension. If any indicated RTP header extension is not supported by the local implementation, it MUST be ignored.</li>
<li>For each specified RTCP feedback mechanism that is supported by the local implementation, enable them on the associated media formats.</li>
<li>For any specified "TIAS" bandwidth value, set this value as a constraint on the maximum RTP bitrate to be used when sending media, as specified in <a href="#RFC3890" class="xref">[RFC3890]</a>. If a "TIAS" value is not present, but an "AS" value is specified, generate a "TIAS" value using this formula: <dl>
<dt> </dt>
<dd>TIAS = AS * 1000 * 0.95 - (50 * 40 * 8)</dd>
</dl>
<p>The 50 is based on 50 packets per second, the 40 is based on an estimate of total header size, the 1000 changes the unit from kbps to bps (as required by TIAS), and the 0.95 is to allocate 5% to RTCP. "TIAS" is used in preference to "AS" because it provides more accurate control of bandwidth.</p>
</li>
<li>For any "RR" or "RS" bandwidth values, handle as specified in <a href="#RFC3556" class="xref">[RFC3556]</a>, Section 2.</li>
<li>Any specified "CT" bandwidth value MUST be ignored, as the meaning of this construct at the media level is not well defined.</li>
<li>If the m= section is of type audio: <ul>
<li>For each specified "CN" media format, configure silence suppression for all supported media formats with the same clockrate, as described in <a href="#RFC3389" class="xref">[RFC3389]</a>, Section 5, except for formats that have their own internal silence suppression mechanisms. Silence suppression for such formats (e.g., Opus) is controlled via fmtp parameters, as discussed in <a href="#sec.voiceactivitydetection1" class="xref">Section 5.2.3.2</a>.</li>
<li>For each specified "telephone-event" media format, enable DTMF transmission for all supported media formats with the same clockrate, as described in <a href="#RFC4733" class="xref">[RFC4733]</a>, Section 2.5.1.2. If there are any supported media formats that do not have a corresponding telephone-event format, disable DTMF transmission for those formats.</li>
<li>For any specified "ptime" value, configure the available media formats to use the specified packet size when sending. If the specified size is not supported for a media format, use the next closest value instead.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p id="rfc.section.5.10.p.5">Finally, if this description is of type "pranswer" or "answer", follow the processing defined in <a href="#sec.applying-an-answer" class="xref">Section 5.11</a> below.</p>
<h2 id="rfc.section.5.11">
<a href="#rfc.section.5.11">5.11.</a> <a href="#sec.applying-an-answer" id="sec.applying-an-answer">Applying an Answer</a>
</h2>
<p id="rfc.section.5.11.p.1">In addition to the steps mentioned above for processing a local or remote description, the following steps are performed when processing a description of type "pranswer" or "answer".</p>
<p id="rfc.section.5.11.p.2">For each m= section, the following steps MUST be performed: </p>

<ul>
<li>If the m= section has been rejected (i.e. port is set to zero in the answer), stop any reception or transmission of media for this section, and, unless a non-rejected m= section is bundled with this m= section, discard any associated ICE components, as described in <a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a>, Section 3.4.3.1.</li>
<li>If the remote DTLS fingerprint has been changed or the tls-id has changed, tear down the DTLS connection. This includes the case when the PeerConnection state is "have-remote-pranswer". If a DTLS connection needs to be torn down but the answer does not indicate an ICE restart or, in the case of "have-remote-pranswer", new ICE credentials, an error MUST be generated. If an ICE restart is performed without a change in tls-id or fingerprint, then the same DTLS connection is continued over the new ICE channel. Note that although JSEP requires that answerers change the tls-id value if and only if the offerer does, non-JSEP answerers are permitted to change the tls-id as long as the offer contained an ICE restart. Thus, JSEP implementations which process DTLS data prior to receiving an answer MUST be prepared to receive either a ClientHello or data from the previous DTLS connection.</li>
<li>If no valid DTLS connection exists, prepare to start a DTLS connection, using the specified roles and fingerprints, on any underlying ICE components, once they are active.</li>
<li>If the m= section proto value indicates use of RTP: <ul>
<li>If the m= section references RTCP feedback mechanisms that were not present in the corresponding m= section in the offer, this indicates a negotiation problem and MUST result in an error. However, new media formats and new RTP header extension values are permitted in the answer, as described in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 7, and <a href="#RFC5285" class="xref">[RFC5285]</a>, Section 6.</li>
<li>If the m= section has RTCP mux enabled, discard the RTCP ICE component, if one exists, and begin or continue muxing RTCP over the RTP ICE component, as specified in <a href="#RFC5761" class="xref">[RFC5761]</a>, Section 5.1.3. Otherwise, prepare to transmit RTCP over the RTCP ICE component; if no RTCP ICE component exists, because RTCP mux was previously enabled, this MUST result in an error.</li>
<li>If the m= section has reduced-size RTCP enabled, configure the RTCP transmission for this m= section to use reduced-size RTCP, as specified in <a href="#RFC5506" class="xref">[RFC5506]</a>.</li>
<li>If the directional attribute in the answer indicates that the JSEP implementation should be sending media ("sendonly" for local answers, "recvonly" for remote answers, or "sendrecv" for either type of answer), choose the media format to send as the most preferred media format from the remote description that is also locally supported, as discussed in <a href="#RFC3264" class="xref">[RFC3264]</a>, Sections 6.1 and 7, and start transmitting RTP media using that format once the underlying transport layers have been established. If an SSRC has not already been chosen for this outgoing RTP stream, choose a random one. If media is already being transmitted, the same SSRC SHOULD be used unless the clockrate of the new codec is different, in which case a new SSRC MUST be chosen, as specified in <a href="#RFC7160" class="xref">[RFC7160]</a>, Section 3.1.</li>
<li>The payload type mapping from the remote description is used to determine payload types for the outgoing RTP streams, including the payload type for the send media format chosen above. Any RTP header extensions that were negotiated should be included in the outgoing RTP streams, using the extension mapping from the remote description; if the RID header extension has been negotiated, and RID values are specified, include the RID header extension in the outgoing RTP streams, as indicated in <a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a>, Section 4.</li>
<li>If the m= section is of type audio, and silence suppression was configured for the send media format as a result of processing the remote description, and is also enabled for that format in the local description, use silence suppression for outgoing media, in accordance with the guidance in <a href="#sec.voiceactivitydetection1" class="xref">Section 5.2.3.2</a>. If these conditions are not met, silence suppression MUST NOT be used for outgoing media.</li>
<li>If simulcast has been negotiated, send the number of Source RTP Streams as specified in <a href="#I-D.ietf-mmusic-sdp-simulcast" class="xref">[I-D.ietf-mmusic-sdp-simulcast]</a>, Section 6.2.2.</li>
<li>If the send media format chosen above has a corresponding "rtx" media format, or a FEC mechanism has been negotiated, establish a Redundancy RTP Stream with a random SSRC for each Source RTP Stream, and start or continue transmitting RTX/FEC packets as needed.</li>
<li>If the send media format chosen above has a corresponding "red" media format of the same clockrate, allow redundant encoding using the specified format for resiliency purposes, as discussed in <a href="#I-D.ietf-rtcweb-fec" class="xref">[I-D.ietf-rtcweb-fec]</a>, Section 3.2. Note that unlike RTX or FEC media formats, the "red" format is transmitted on the Source RTP Stream, not the Redundancy RTP Stream.</li>
<li>Enable the RTCP feedback mechanisms referenced in the media section for all Source RTP Streams using the specified media formats. Specifically, begin or continue sending the requested feedback types and reacting to received feedback, as specified in <a href="#RFC4585" class="xref">[RFC4585]</a>, Section 4.2. When sending RTCP feedback, follow the rules and recommendations from <a href="#RFC8108" class="xref">[RFC8108]</a> Section 5.4.1, to select which SSRC to use.</li>
<li>If the directional attribute in the answer indicates that the JSEP implementation should not be sending media ("recvonly" for local answers, "sendonly" for remote answers, or "inactive" for either type of answer) stop transmitting all RTP media, but continue sending RTCP, as described in <a href="#RFC3264" class="xref">[RFC3264]</a>, Section 5.1.</li>
</ul>
</li>
<li>If the m= section proto value indicates use of SCTP: <ul>
<li>If an SCTP association exists, and the remote SCTP port has changed, discard the existing SCTP association. This includes the case when the PeerConnection state is "have-remote-pranswer".</li>
<li>If no valid SCTP association exists, prepare to initiate a SCTP association over the associated ICE component and DTLS connection, using the local SCTP port value from the local description, and the remote SCTP port value from the remote description, as described in <a href="#I-D.ietf-mmusic-sctp-sdp" class="xref">[I-D.ietf-mmusic-sctp-sdp]</a>, Section 10.2.</li>
</ul>
</li>
</ul>
<p id="rfc.section.5.11.p.3">If the answer contains valid bundle groups, discard any ICE components for the m= sections that will be bundled onto the primary ICE components in each bundle, and begin muxing these m= sections accordingly, as described in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 8.2.</p>
<p id="rfc.section.5.11.p.4">If the description is of type "answer", and there are still remaining candidates in the ICE candidate pool, discard them.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#sec.rtp.demux" id="sec.rtp.demux">Processing RTP/RTCP</a>
</h1>
<p id="rfc.section.6.p.1">When bundling, associating incoming RTP/RTCP with the proper m= section is defined in <a href="#I-D.ietf-mmusic-sdp-bundle-negotiation" class="xref">[I-D.ietf-mmusic-sdp-bundle-negotiation]</a>, Section 10.2. When not bundling, the proper m= section is clear from the ICE component over which the RTP/RTCP is received.</p>
<p id="rfc.section.6.p.2">Once the proper m= section(s) are known, RTP/RTCP is delivered to the RtpTransceiver(s) associated with the m= section(s) and further processing of the RTP/RTCP is done at the RtpTransceiver level. This includes using RID <a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a> to distinguish between multiple Encoded Streams, as well as determine which Source RTP stream should be repaired by a given Redundancy RTP stream.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sec.examples" id="sec.examples">Examples</a>
</h1>
<p id="rfc.section.7.p.1">Note that this example section shows several SDP fragments. To format in 72 columns, some of the lines in SDP have been split into multiple lines, where leading whitespace indicates that a line is a continuation of the previous line. In addition, some blank lines have been added to improve readability but are not valid in SDP.</p>
<p id="rfc.section.7.p.2">More examples of SDP for WebRTC call flows, including examples with IPv6 addresses, can be found in <a href="#I-D.ietf-rtcweb-sdp" class="xref">[I-D.ietf-rtcweb-sdp]</a>.</p>
<h2 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#sec.simple-examples" id="sec.simple-examples">Simple Example</a>
</h2>
<p id="rfc.section.7.1.p.1">This section shows a very simple example that sets up a minimal audio / video call between two JSEP endpoints without using trickle ICE. The example in the following section provides a more detailed example of what could happen in a JSEP session.</p>
<p id="rfc.section.7.1.p.2">The code flow below shows Alice's endpoint initiating the session to Bob's endpoint. The messages from the JavaScript application in Alice's browser to the JavaScript in Bob's browser, abbreviated as AliceJS and BobJS respectively, are assumed to flow over some signaling protocol via a web server.  The JavaScript on both Alice's side and Bob's side waits for all candidates before sending the offer or answer, so the offers and answers are complete; trickle ICE is not used. The user agents (JSEP implementations) in Alice and Bob's browsers, abbreviated as AliceUA and BobUA respectively, are using the default bundle policy of "balanced", and the default RTCP mux policy of "require".</p>
<pre>
              
//                  set up local media state
AliceJS-&gt;AliceUA:   create new PeerConnection
AliceJS-&gt;AliceUA:   addTrack with two tracks: audio and video
AliceJS-&gt;AliceUA:   createOffer to get offer
AliceJS-&gt;AliceUA:   setLocalDescription with offer
AliceUA-&gt;AliceJS:   multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
AliceUA-&gt;AliceJS:   onicecandidate event with null candidate
AliceJS-&gt;AliceUA:   get |offer-A1| from pendingLocalDescription

//                  |offer-A1| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |offer-A1|
WebServer-&gt;BobJS:   signaling with |offer-A1|

//                  |offer-A1| arrives at Bob
BobJS-&gt;BobUA:       create a PeerConnection
BobJS-&gt;BobUA:       setRemoteDescription with |offer-A1|
BobUA-&gt;BobJS:       ontrack events for audio and video tracks

//                  Bob accepts call
BobJS-&gt;BobUA:       addTrack with local tracks
BobJS-&gt;BobUA:       createAnswer
BobJS-&gt;BobUA:       setLocalDescription with answer
BobUA-&gt;BobJS:       multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
BobUA-&gt;BobJS:       onicecandidate event with null candidate
BobJS-&gt;BobUA:       get |answer-A1| from currentLocalDescription

//                  |answer-A1| is sent over signaling protocol to Alice
BobJS-&gt;WebServer:   signaling with |answer-A1|
WebServer-&gt;AliceJS: signaling with |answer-A1|

//                  |answer-A1| arrives at Alice
AliceJS-&gt;AliceUA:   setRemoteDescription with |answer-A1|
AliceUA-&gt;AliceJS:   ontrack events for audio and video tracks

//                  media flows
BobUA-&gt;AliceUA:     media sent from Bob to Alice
AliceUA-&gt;BobUA:     media sent from Alice to Bob

</pre>
<p></p>
<p id="rfc.section.7.1.p.4">The SDP for |offer-A1| looks like:</p>
<pre>
              
v=0
o=- 4962303333179871722 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 10100 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 203.0.113.100
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:47017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:ETEn
a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=tls-id:91bbf309c0990a6bec11e38ba2933cee
a=rtcp:10101 IN IP4 203.0.113.100
a=rtcp-mux
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host
a=candidate:1 2 udp 2113929470 203.0.113.100 10101 typ host
a=end-of-candidates

m=video 10102 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 203.0.113.100
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:47017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:BGKk
a=ice-pwd:mqyWsAjvtKwTGnvhPztQ9mIf
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=tls-id:91bbf309c0990a6bec11e38ba2933cee
a=rtcp:10103 IN IP4 203.0.113.100
a=rtcp-mux
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.100 10102 typ host
a=candidate:1 2 udp 2113929470 203.0.113.100 10103 typ host
a=end-of-candidates

</pre>
<p></p>
<p id="rfc.section.7.1.p.6">The SDP for |answer-A1| looks like:</p>
<pre>
              
v=0
o=- 6729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 10200 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 203.0.113.200
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae
a=ice-ufrag:6sFv
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:
              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=tls-id:eec3392ab83e11ceb6a0990c903fbb19
a=rtcp-mux
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host
a=end-of-candidates

m=video 10200 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 203.0.113.200
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae

</pre>
<p></p>
<h2 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#sec.detailed-example" id="sec.detailed-example">Detailed Example</a>
</h2>
<p id="rfc.section.7.2.p.1">This section shows a more involved example of a session between two JSEP endpoints. Trickle ICE is used in full trickle mode, with a bundle policy of "max-bundle", an RTCP mux policy of "require", and a single TURN server. Initially, both Alice and Bob establish an audio channel and a data channel. Later, Bob adds two video flows, one for his video feed, and one for screensharing, both supporting FEC, and with the video feed configured for simulcast. Alice accepts these video flows, but does not add video flows of her own, so they are handled as recvonly. Alice also specifies a maximum video decoder resolution.</p>
<pre>
              
//                  set up local media state
AliceJS-&gt;AliceUA:   create new PeerConnection
AliceJS-&gt;AliceUA:   addTrack with an audio track
AliceJS-&gt;AliceUA:   createDataChannel to get data channel
AliceJS-&gt;AliceUA:   createOffer to get |offer-B1|
AliceJS-&gt;AliceUA:   setLocalDescription with |offer-B1|

//                  |offer-B1| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |offer-B1|
WebServer-&gt;BobJS:   signaling with |offer-B1|

//                  |offer-B1| arrives at Bob
BobJS-&gt;BobUA:       create a PeerConnection
BobJS-&gt;BobUA:       setRemoteDescription with |offer-B1|
BobUA-&gt;BobJS:       ontrack with audio track from Alice

//                  candidates are sent to Bob
AliceUA-&gt;AliceJS:   onicecandidate (host) |offer-B1-candidate-1|
AliceJS-&gt;WebServer: signaling with |offer-B1-candidate-1|
AliceUA-&gt;AliceJS:   onicecandidate (srflx) |offer-B1-candidate-2|
AliceJS-&gt;WebServer: signaling with |offer-B1-candidate-2|
AliceUA-&gt;AliceJS:   onicecandidate (relay) |offer-B1-candidate-3|
AliceJS-&gt;WebServer: signaling with |offer-B1-candidate-3|

WebServer-&gt;BobJS:   signaling with |offer-B1-candidate-1|
BobJS-&gt;BobUA:       addIceCandidate with |offer-B1-candidate-1|
WebServer-&gt;BobJS:   signaling with |offer-B1-candidate-2|
BobJS-&gt;BobUA:       addIceCandidate with |offer-B1-candidate-2|
WebServer-&gt;BobJS:   signaling with |offer-B1-candidate-3|
BobJS-&gt;BobUA:       addIceCandidate with |offer-B1-candidate-3|

//                  Bob accepts call
BobJS-&gt;BobUA:       addTrack with local audio
BobJS-&gt;BobUA:       createDataChannel to get data channel
BobJS-&gt;BobUA:       createAnswer to get |answer-B1|
BobJS-&gt;BobUA:       setLocalDescription with |answer-B1|

//                  |answer-B1| is sent to Alice
BobJS-&gt;WebServer:   signaling with |answer-B1|
WebServer-&gt;AliceJS: signaling with |answer-B1|
AliceJS-&gt;AliceUA:   setRemoteDescription with |answer-B1|
AliceUA-&gt;AliceJS:   ontrack event with audio track from Bob

//                  candidates are sent to Alice
BobUA-&gt;BobJS:       onicecandidate (host) |answer-B1-candidate-1|
BobJS-&gt;WebServer:   signaling with |answer-B1-candidate-1|
BobUA-&gt;BobJS:       onicecandidate (srflx) |answer-B1-candidate-2|
BobJS-&gt;WebServer:   signaling with |answer-B1-candidate-2|
BobUA-&gt;BobJS:       onicecandidate (relay) |answer-B1-candidate-3|
BobJS-&gt;WebServer:   signaling with |answer-B1-candidate-3|

WebServer-&gt;AliceJS: signaling with |answer-B1-candidate-1|
AliceJS-&gt;AliceUA:   addIceCandidate with |answer-B1-candidate-1|
WebServer-&gt;AliceJS: signaling with |answer-B1-candidate-2|
AliceJS-&gt;AliceUA:   addIceCandidate with |answer-B1-candidate-2|
WebServer-&gt;AliceJS: signaling with |answer-B1-candidate-3|
AliceJS-&gt;AliceUA:   addIceCandidate with |answer-B1-candidate-3|

//                  data channel opens
BobUA-&gt;BobJS:       ondatachannel event
AliceUA-&gt;AliceJS:   ondatachannel event
BobUA-&gt;BobJS:       onopen
AliceUA-&gt;AliceJS:   onopen

//                  media is flowing between endpoints
BobUA-&gt;AliceUA:     audio+data sent from Bob to Alice
AliceUA-&gt;BobUA:     audio+data sent from Alice to Bob

//                  some time later Bob adds two video streams
//                  note, no candidates exchanged, because of bundle
BobJS-&gt;BobUA:       addTrack with first video stream
BobJS-&gt;BobUA:       addTrack with second video stream
BobJS-&gt;BobUA:       createOffer to get |offer-B2|
BobJS-&gt;BobUA:       setLocalDescription with |offer-B2|

//                  |offer-B2| is sent to Alice
BobJS-&gt;WebServer:   signaling with |offer-B2|
WebServer-&gt;AliceJS: signaling with |offer-B2|
AliceJS-&gt;AliceUA:   setRemoteDescription with |offer-B2|
AliceUA-&gt;AliceJS:   ontrack event with first video track
AliceUA-&gt;AliceJS:   ontrack event with second video track
AliceJS-&gt;AliceUA:   createAnswer to get |answer-B2|
AliceJS-&gt;AliceUA:   setLocalDescription with |answer-B2|

//                  |answer-B2| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |answer-B2|
WebServer-&gt;BobJS:   signaling with |answer-B2|
BobJS-&gt;BobUA:       setRemoteDescription with |answer-B2|

//                  media is flowing between endpoints
BobUA-&gt;AliceUA:     audio+video+data sent from Bob to Alice
AliceUA-&gt;BobUA:     audio+video+data sent from Alice to Bob

</pre>
<p></p>
<p id="rfc.section.7.2.p.3">The SDP for |offer-B1| looks like:</p>
<pre>
              
v=0
o=- 4962303333179871723 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:57017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:ATEn
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              29:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=tls-id:17f0f4ba8a5f1213faca591b58ba52a7
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=application 0 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536
a=bundle-only

</pre>
<p></p>
<p id="rfc.section.7.2.p.5">|offer-B1-candidate-1| looks like:</p>
<pre>
              
ufrag ATEn
index 0
mid   a1
attr  candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host

</pre>
<p></p>
<p id="rfc.section.7.2.p.7">|offer-B1-candidate-2| looks like:</p>
<pre>
              
ufrag ATEn
index 0
mid   a1
attr  candidate:1 1 udp 1845494015 198.51.100.100 11100 typ srflx
                raddr 203.0.113.100 rport 10100

</pre>
<p></p>
<p id="rfc.section.7.2.p.9">|offer-B1-candidate-3| looks like:</p>
<pre>
              
ufrag ATEn
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.100 12100 typ relay
                raddr 198.51.100.100 rport 11100

</pre>
<p></p>
<p id="rfc.section.7.2.p.11">The SDP for |answer-B1| looks like:</p>
<pre>
              
v=0
o=- 7729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
a=ice-ufrag:7sFv
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              7B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:
              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=tls-id:7a25ab85b195acaf3121f5a8ab4f0f71
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=application 9 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 0.0.0.0
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536

</pre>
<p></p>
<p id="rfc.section.7.2.p.13">|answer-B1-candidate-1| looks like:</p>
<pre>
              
ufrag 7sFv
index 0
mid   a1
attr  candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host

</pre>
<p></p>
<p id="rfc.section.7.2.p.15">|answer-B1-candidate-2| looks like:</p>
<pre>
              
ufrag 7sFv
index 0
mid   a1
attr  candidate:1 1 udp 1845494015 198.51.100.200 11200 typ srflx
                raddr 203.0.113.200 rport 10200

</pre>
<p></p>
<p id="rfc.section.7.2.p.17">|answer-B1-candidate-3| looks like:</p>
<pre>
              
ufrag 7sFv
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.200 12200 typ relay
                raddr 198.51.100.200 rport 11200

</pre>
<p></p>
<p id="rfc.section.7.2.p.19">The SDP for |offer-B2| is shown below. In addition to the new m= sections for video, both of which are offering FEC, and one of which is offering simulcast, note the increment of the version number in the o= line, changes to the c= line, indicating the local candidate that was selected, and the inclusion of gathered candidates as a=candidate lines.</p>
<pre>
              
v=0
o=- 7729291447651054566 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1 v1 v2
a=group:LS a1 v1

m=audio 12200 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.200
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
a=ice-ufrag:7sFv
a=ice-pwd:dOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256
              7B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35:
              DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:actpass
a=tls-id:7a25ab85b195acaf3121f5a8ab4f0f71
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.200 10200 typ host
a=candidate:1 1 udp 1845494015 198.51.100.200 11200 typ srflx
            raddr 203.0.113.200 rport 10200
a=candidate:1 1 udp 255 192.0.2.200 12200 typ relay
            raddr 198.51.100.200 rport 11200
a=end-of-candidates

m=application 12200 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 192.0.2.200
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536

m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103 104
c=IN IP4 192.0.2.200
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=rtpmap:104 flexfec/90000
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:71317484-2ed4-49d7-9eb7-1414322a7aae
a=rid:1 send
a=rid:2 send
a=rid:3 send
a=simulcast:send 1;2;3

m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103 104
c=IN IP4 192.0.2.200
a=mid:v2
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=rtpmap:104 flexfec/90000
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:81317484-2ed4-49d7-9eb7-1414322a7aae

</pre>
<p></p>
<p id="rfc.section.7.2.p.21">The SDP for |answer-B2| is shown below. In addition to the acceptance of the video m= sections, the use of a=recvonly to indicate one-way video, and the use of a=imageattr to limit the received resolution, note the use of setup:passive to maintain the existing DTLS roles.</p>
<pre>
              
v=0
o=- 4962303333179871723 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 d1 v1 v2
a=group:LS a1 v1

m=audio 12100 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.100
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:57017fee-b6c1-4162-929c-a25110252400
a=ice-ufrag:ATEn
a=ice-pwd:AtSK0WpNtpUjkY4+86js7ZQl
a=fingerprint:sha-256
              29:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04:
              BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:passive
a=tls-id:17f0f4ba8a5f1213faca591b58ba52a7
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 2113929471 203.0.113.100 10100 typ host
a=candidate:1 1 udp 1845494015 198.51.100.100 11100 typ srflx
            raddr 203.0.113.100 rport 10100
a=candidate:1 1 udp 255 192.0.2.100 12100 typ relay
            raddr 198.51.100.100 rport 11100
a=end-of-candidates

m=application 12100 UDP/DTLS/SCTP webrtc-datachannel
c=IN IP4 192.0.2.100
a=mid:d1
a=sctp-port:5000
a=max-message-size:65536

m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.100
a=mid:v1
a=recvonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=imageattr:100 recv [x=[48:1920],y=[48:1080],q=1.0]
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli

m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.100
a=mid:v2
a=recvonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=imageattr:100 recv [x=[48:1920],y=[48:1080],q=1.0]
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli

</pre>
<p></p>
<h2 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#sec.warmup-example" id="sec.warmup-example">Early Transport Warmup Example</a>
</h2>
<p id="rfc.section.7.3.p.1">This example demonstrates the early warmup technique described in <a href="#sec.use-of-provisional-answer" class="xref">Section 4.1.8.1</a>. Here, Alice's endpoint sends an offer to Bob's endpoint to start an audio/video call. Bob immediately responds with an answer that accepts the audio/video m= sections, but marks them as sendonly (from his perspective), meaning that Alice will not yet send media. This allows the JSEP implementation to start negotiating ICE and DTLS immediately. Bob's endpoint then prompts him to answer the call, and when he does, his endpoint sends a second offer which enables the audio and video m= sections, and thereby bidirectional media transmission. The advantage of such a flow is that as soon as the first answer is received, the implementation can proceed with ICE and DTLS negotiation and establish the session transport. If the transport setup completes before the second offer is sent, then media can be transmitted immediately by the callee immediately upon answering the call, minimizing perceived post-dial-delay. The second offer/answer exchange can also change the preferred codecs or other session parameters.</p>
<p id="rfc.section.7.3.p.2">This example also makes use of the "relay" ICE candidate policy described in <a href="#sec.ice-candidate-policy" class="xref">Section 3.5.3</a> to minimize the ICE gathering and checking needed.</p>
<pre>
              
//                  set up local media state
AliceJS-&gt;AliceUA:   create new PeerConnection with "relay" ICE policy
AliceJS-&gt;AliceUA:   addTrack with two tracks: audio and video
AliceJS-&gt;AliceUA:   createOffer to get |offer-C1|
AliceJS-&gt;AliceUA:   setLocalDescription with |offer-C1|

//                  |offer-C1| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |offer-C1|
WebServer-&gt;BobJS:   signaling with |offer-C1|

//                  |offer-C1| arrives at Bob
BobJS-&gt;BobUA:       create new PeerConnection with "relay" ICE policy
BobJS-&gt;BobUA:       setRemoteDescription with |offer-C1|
BobUA-&gt;BobJS:       ontrack events for audio and video

//                  a relay candidate is sent to Bob
AliceUA-&gt;AliceJS:   onicecandidate (relay) |offer-C1-candidate-1|
AliceJS-&gt;WebServer: signaling with |offer-C1-candidate-1|

WebServer-&gt;BobJS:   signaling with |offer-C1-candidate-1|
BobJS-&gt;BobUA:       addIceCandidate with |offer-C1-candidate-1|

//                  Bob prepares an early answer to warmup the transport
BobJS-&gt;BobUA:       addTransceiver with null audio and video tracks
BobJS-&gt;BobUA:       transceiver.setDirection(sendonly) for both
BobJS-&gt;BobUA:       createAnswer
BobJS-&gt;BobUA:       setLocalDescription with answer

//                  |answer-C1| is sent over signaling protocol to Alice
BobJS-&gt;WebServer:   signaling with |answer-C1|
WebServer-&gt;AliceJS: signaling with |answer-C1|

//                  |answer-C1| (sendonly) arrives at Alice
AliceJS-&gt;AliceUA:   setRemoteDescription with |answer-C1|
AliceUA-&gt;AliceJS:   ontrack events for audio and video

//                  a relay candidate is sent to Alice
BobUA-&gt;BobJS:       onicecandidate (relay) |answer-B1-candidate-1|
BobJS-&gt;WebServer:   signaling with |answer-B1-candidate-1|

WebServer-&gt;AliceJS: signaling with |answer-B1-candidate-1|
AliceJS-&gt;AliceUA:   addIceCandidate with |answer-B1-candidate-1|

//                  ICE and DTLS establish while call is ringing

//                  Bob accepts call, starts media, and sends new offer
BobJS-&gt;BobUA:       transceiver.setTrack with audio and video tracks
BobUA-&gt;AliceUA:     media sent from Bob to Alice
BobJS-&gt;BobUA:       transceiver.setDirection(sendrecv) for both
                    transceivers
BobJS-&gt;BobUA:       createOffer
BobJS-&gt;BobUA:       setLocalDescription with offer

//                  |offer-C2| is sent over signaling protocol to Alice
BobJS-&gt;WebServer:   signaling with |offer-C2|
WebServer-&gt;AliceJS: signaling with |offer-C2|

//                  |offer-C2| (sendrecv) arrives at Alice
AliceJS-&gt;AliceUA:   setRemoteDescription with |offer-C2|
AliceJS-&gt;AliceUA:   createAnswer
AliceJS-&gt;AliceUA:   setLocalDescription with |answer-C2|
AliceUA-&gt;BobUA:     media sent from Alice to Bob

//                  |answer-C2| is sent over signaling protocol to Bob
AliceJS-&gt;WebServer: signaling with |answer-C2|
WebServer-&gt;BobJS:   signaling with |answer-C2|
BobJS-&gt;BobUA:       setRemoteDescription with |answer-C2|

</pre>
<p></p>
<p id="rfc.section.7.3.p.4">The SDP for |offer-C1| looks like:</p>
<pre>
              
v=0
o=- 1070771854436052752 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce
a=ice-ufrag:4ZcD
a=ice-pwd:ZaaG6OG7tCn4J/lehAGz+HHD
a=fingerprint:sha-256
              C4:68:F8:77:6A:44:F1:98:6D:7C:9F:47:EB:E3:34:A4:
              0A:AA:2D:49:08:28:70:2E:1F:AE:18:7D:4E:3E:66:BF
a=setup:actpass
a=tls-id:9e5b948ade9c3d41de6617b68f769e55
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=video 0 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 0.0.0.0
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce
a=bundle-only

</pre>
<p></p>
<p id="rfc.section.7.3.p.6">|offer-C1-candidate-1| looks like:</p>
<pre>
              
ufrag 4ZcD
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.100 12100 typ relay
                raddr 0.0.0.0 rport 0

</pre>
<p></p>
<p id="rfc.section.7.3.p.8">The SDP for |answer-C1| looks like:</p>
<pre>
              
v=0
o=- 6386516489780559513 1 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 9 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 0.0.0.0
a=mid:a1
a=sendonly
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:751f239e-4ae0-c549-aa3d-890de772998b
a=ice-ufrag:TpaA
a=ice-pwd:t2Ouhc67y8JcCaYZxUUTgKw/
a=fingerprint:sha-256
              A2:F3:A5:6D:4C:8C:1E:B2:62:10:4A:F6:70:61:C4:FC:
              3C:E0:01:D6:F3:24:80:74:DA:7C:3E:50:18:7B:CE:4D
a=setup:active
a=tls-id:55e967f86b7166ed14d3c9eda849b5e9
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize

m=video 9 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 0.0.0.0
a=mid:v1
a=sendonly
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:751f239e-4ae0-c549-aa3d-890de772998b

</pre>
<p></p>
<p id="rfc.section.7.3.p.10">|answer-C1-candidate-1| looks like:</p>
<pre>
              
ufrag TpaA
index 0
mid   a1
attr  candidate:1 1 udp 255 192.0.2.200 12200 typ relay
                raddr 0.0.0.0 rport 0

</pre>
<p></p>
<p id="rfc.section.7.3.p.12">The SDP for |offer-C2| looks like:</p>
<pre>
              
v=0
o=- 6386516489780559513 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 12200 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.200
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:751f239e-4ae0-c549-aa3d-890de772998b
a=ice-ufrag:TpaA
a=ice-pwd:t2Ouhc67y8JcCaYZxUUTgKw/
a=fingerprint:sha-256
              A2:F3:A5:6D:4C:8C:1E:B2:62:10:4A:F6:70:61:C4:FC:
              3C:E0:01:D6:F3:24:80:74:DA:7C:3E:50:18:7B:CE:4D
a=setup:actpass
a=tls-id:55e967f86b7166ed14d3c9eda849b5e9
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 255 192.0.2.200 12200 typ relay
            raddr 0.0.0.0 rport 0
a=end-of-candidates

m=video 12200 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.200
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:751f239e-4ae0-c549-aa3d-890de772998b

</pre>
<p></p>
<p id="rfc.section.7.3.p.14">The SDP for |answer-C2| looks like:</p>
<pre>
              
v=0
o=- 1070771854436052752 2 IN IP4 0.0.0.0
s=-
t=0 0
a=ice-options:trickle ice2
a=group:BUNDLE a1 v1
a=group:LS a1 v1

m=audio 12100 UDP/TLS/RTP/SAVPF 96 0 8 97 98
c=IN IP4 192.0.2.100
a=mid:a1
a=sendrecv
a=rtpmap:96 opus/48000/2
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:97 telephone-event/8000
a=rtpmap:98 telephone-event/48000
a=fmtp:97 0-15
a=fmtp:98 0-15
a=maxptime:120
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:2 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce
a=ice-ufrag:4ZcD
a=ice-pwd:ZaaG6OG7tCn4J/lehAGz+HHD
a=fingerprint:sha-256
              C4:68:F8:77:6A:44:F1:98:6D:7C:9F:47:EB:E3:34:A4:
              0A:AA:2D:49:08:28:70:2E:1F:AE:18:7D:4E:3E:66:BF
a=setup:passive
a=tls-id:9e5b948ade9c3d41de6617b68f769e55
a=rtcp-mux
a=rtcp-mux-only
a=rtcp-rsize
a=candidate:1 1 udp 255 192.0.2.100 12100 typ relay
            raddr 0.0.0.0 rport 0
a=end-of-candidates

m=video 12100 UDP/TLS/RTP/SAVPF 100 101 102 103
c=IN IP4 192.0.2.100
a=mid:v1
a=sendrecv
a=rtpmap:100 VP8/90000
a=rtpmap:101 H264/90000
a=fmtp:101 packetization-mode=1;profile-level-id=42e01f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=100
=rtpmap:103 rtx/90000
a=fmtp:103 apt=101
a=extmap:1 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 nack pli
a=msid:bbce3ba6-abfc-ac63-d00a-e15b286f8fce

</pre>
<p></p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#sec.security-considerations" id="sec.security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.8.p.1">The IETF has published separate documents <a href="#I-D.ietf-rtcweb-security-arch" class="xref">[I-D.ietf-rtcweb-security-arch]</a> <a href="#I-D.ietf-rtcweb-security" class="xref">[I-D.ietf-rtcweb-security]</a> describing the security architecture for WebRTC as a whole. The remainder of this section describes security considerations for this document.</p>
<p id="rfc.section.8.p.2">While formally the JSEP interface is an API, it is better to think of it as an Internet protocol, with the application JavaScript being untrustworthy from the perspective of the JSEP implementation. Thus, the threat model of <a href="#RFC3552" class="xref">[RFC3552]</a> applies. In particular, JavaScript can call the API in any order and with any inputs, including malicious ones. This is particularly relevant when we consider the SDP which is passed to setLocalDescription(). While correct API usage requires that the application pass in SDP which was derived from createOffer() or createAnswer(), there is no guarantee that applications do so. The JSEP implementation MUST be prepared for the JavaScript to pass in bogus data instead.</p>
<p id="rfc.section.8.p.3">Conversely, the application programmer needs to be aware that the JavaScript does not have complete control of endpoint behavior. One case that bears particular mention is that editing ICE candidates out of the SDP or suppressing trickled candidates does not have the expected behavior: implementations will still perform checks from those candidates even if they are not sent to the other side. Thus, for instance, it is not possible to prevent the remote peer from learning your public IP address by removing server reflexive candidates. Applications which wish to conceal their public IP address should instead configure the ICE agent to use only relay candidates.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#sec.iana-considerations" id="sec.iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.9.p.1">This document requires no actions from IANA.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#sec.acknowledgements" id="sec.acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.10.p.1">Harald Alvestrand, Taylor Brandstetter, Suhas Nandakumar, and Peter Thatcher provided significant text for this draft. Bernard Aboba, Adam Bergkvist, Dan Burnett, Ben Campbell, Alissa Cooper, Richard Ejzak, Stefan Hakansson, Ted Hardie, Christer Holmberg Andrew Hutton, Randell Jesup, Matthew Kaufman, Anant Narayanan, Adam Roach, Robert Sparks, Neil Stratford, Martin Thomson, Sean Turner, and Magnus Westerlund all provided valuable feedback on this proposal.</p>
<h1 id="rfc.references">
<a href="#rfc.references">11.</a> References</h1>
<h2 id="rfc.references.1">
<a href="#rfc.references.1">11.1.</a> Normative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-avtext-rid">[I-D.ietf-avtext-rid]</b></td>
<td class="top">
<a>Roach, A.</a>, <a>Nandakumar, S.</a> and <a>P. Thatcher</a>, "<a href="https://tools.ietf.org/html/draft-ietf-avtext-rid-09">RTP Stream Identifier Source Description (SDES)</a>", Internet-Draft draft-ietf-avtext-rid-09, October 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ice-trickle">[I-D.ietf-ice-trickle]</b></td>
<td class="top">
<a>Ivov, E.</a>, <a>Rescorla, E.</a>, <a>Uberti, J.</a> and <a>P. Saint-Andre</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ice-trickle-21">Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</a>", Internet-Draft draft-ietf-ice-trickle-21, April 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-dtls-sdp">[I-D.ietf-mmusic-dtls-sdp]</b></td>
<td class="top">
<a>Holmberg, C.</a> and <a>R. Shpount</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-dtls-sdp-32">Session Description Protocol (SDP) Offer/Answer Considerations for Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</a>", Internet-Draft draft-ietf-mmusic-dtls-sdp-32, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-ice-sip-sdp">[I-D.ietf-mmusic-ice-sip-sdp]</b></td>
<td class="top">
<a>Petit-Huguenin, M.</a>, <a>Nandakumar, S.</a> and <a>A. Keranen</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip-sdp-24">Session Description Protocol (SDP) Offer/Answer procedures for Interactive Connectivity Establishment (ICE)</a>", Internet-Draft draft-ietf-mmusic-ice-sip-sdp-24, November 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-msid">[I-D.ietf-mmusic-msid]</b></td>
<td class="top">
<a>Alvestrand, H.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-msid-17">WebRTC MediaStream Identification in the Session Description Protocol</a>", Internet-Draft draft-ietf-mmusic-msid-17, December 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-mux-exclusive">[I-D.ietf-mmusic-mux-exclusive]</b></td>
<td class="top">
<a>Holmberg, C.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-mux-exclusive-12">Indicating Exclusive Support of RTP/RTCP Multiplexing using SDP</a>", Internet-Draft draft-ietf-mmusic-mux-exclusive-12, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-rid">[I-D.ietf-mmusic-rid]</b></td>
<td class="top">
<a>Roach, A.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-rid-15">RTP Payload Format Restrictions</a>", Internet-Draft draft-ietf-mmusic-rid-15, May 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-sctp-sdp">[I-D.ietf-mmusic-sctp-sdp]</b></td>
<td class="top">
<a>Holmberg, C.</a>, <a>Shpount, R.</a>, <a>Loreto, S.</a> and <a>G. Camarillo</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26">Session Description Protocol (SDP) Offer/Answer Procedures For Stream Control Transmission Protocol (SCTP) over Datagram Transport Layer Security (DTLS) Transport.</a>", Internet-Draft draft-ietf-mmusic-sctp-sdp-26, April 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-sdp-bundle-negotiation">[I-D.ietf-mmusic-sdp-bundle-negotiation]</b></td>
<td class="top">
<a>Holmberg, C.</a>, <a>Alvestrand, H.</a> and <a>C. Jennings</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-54">Negotiating Media Multiplexing Using the Session Description Protocol (SDP)</a>", Internet-Draft draft-ietf-mmusic-sdp-bundle-negotiation-54, December 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-sdp-mux-attributes">[I-D.ietf-mmusic-sdp-mux-attributes]</b></td>
<td class="top">
<a>Nandakumar, S.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-sdp-mux-attributes-17">A Framework for SDP Attributes when Multiplexing</a>", Internet-Draft draft-ietf-mmusic-sdp-mux-attributes-17, February 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-sdp-simulcast">[I-D.ietf-mmusic-sdp-simulcast]</b></td>
<td class="top">
<a>Burman, B.</a>, <a>Westerlund, M.</a>, <a>Nandakumar, S.</a> and <a>M. Zanaty</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-13">Using Simulcast in SDP and RTP Sessions</a>", Internet-Draft draft-ietf-mmusic-sdp-simulcast-13, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-fec">[I-D.ietf-rtcweb-fec]</b></td>
<td class="top">
<a>Uberti, J.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-fec-08">WebRTC Forward Error Correction Requirements</a>", Internet-Draft draft-ietf-rtcweb-fec-08, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</b></td>
<td class="top">
<a>Perkins, C.</a>, <a>Westerlund, M.</a> and <a>J. Ott</a>, "<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-26">Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</a>", Internet-Draft draft-ietf-rtcweb-rtp-usage-26, March 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-security-11">Security Considerations for WebRTC</a>", Internet-Draft draft-ietf-rtcweb-security-11, February 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-security-arch">[I-D.ietf-rtcweb-security-arch]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-security-arch-18">WebRTC Security Architecture</a>", Internet-Draft draft-ietf-rtcweb-security-arch-18, February 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3261">[RFC3261]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="https://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, DOI 10.17487/RFC3261, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3264">[RFC3264]</b></td>
<td class="top">
<a>Rosenberg, J.</a> and <a>H. Schulzrinne</a>, "<a href="https://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>", RFC 3264, DOI 10.17487/RFC3264, June 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3552">[RFC3552]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="https://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3605">[RFC3605]</b></td>
<td class="top">
<a>Huitema, C.</a>, "<a href="https://tools.ietf.org/html/rfc3605">Real Time Control Protocol (RTCP) attribute in Session Description Protocol (SDP)</a>", RFC 3605, DOI 10.17487/RFC3605, October 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3711">[RFC3711]</b></td>
<td class="top">
<a>Baugher, M.</a>, <a>McGrew, D.</a>, <a>Naslund, M.</a>, <a>Carrara, E.</a> and <a>K. Norrman</a>, "<a href="https://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>", RFC 3711, DOI 10.17487/RFC3711, March 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3890">[RFC3890]</b></td>
<td class="top">
<a>Westerlund, M.</a>, "<a href="https://tools.ietf.org/html/rfc3890">A Transport Independent Bandwidth Modifier for the Session Description Protocol (SDP)</a>", RFC 3890, DOI 10.17487/RFC3890, September 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4145">[RFC4145]</b></td>
<td class="top">
<a>Yon, D.</a> and <a>G. Camarillo</a>, "<a href="https://tools.ietf.org/html/rfc4145">TCP-Based Media Transport in the Session Description Protocol (SDP)</a>", RFC 4145, DOI 10.17487/RFC4145, September 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4566">[RFC4566]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="https://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, DOI 10.17487/RFC4566, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4585">[RFC4585]</b></td>
<td class="top">
<a>Ott, J.</a>, <a>Wenger, S.</a>, <a>Sato, N.</a>, <a>Burmeister, C.</a> and <a>J. Rey</a>, "<a href="https://tools.ietf.org/html/rfc4585">Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)</a>", RFC 4585, DOI 10.17487/RFC4585, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5124">[RFC5124]</b></td>
<td class="top">
<a>Ott, J.</a> and <a>E. Carrara</a>, "<a href="https://tools.ietf.org/html/rfc5124">Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)</a>", RFC 5124, DOI 10.17487/RFC5124, February 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5285">[RFC5285]</b></td>
<td class="top">
<a>Singer, D.</a> and <a>H. Desineni</a>, "<a href="https://tools.ietf.org/html/rfc5285">A General Mechanism for RTP Header Extensions</a>", RFC 5285, DOI 10.17487/RFC5285, July 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5761">[RFC5761]</b></td>
<td class="top">
<a>Perkins, C.</a> and <a>M. Westerlund</a>, "<a href="https://tools.ietf.org/html/rfc5761">Multiplexing RTP Data and Control Packets on a Single Port</a>", RFC 5761, DOI 10.17487/RFC5761, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5888">[RFC5888]</b></td>
<td class="top">
<a>Camarillo, G.</a> and <a>H. Schulzrinne</a>, "<a href="https://tools.ietf.org/html/rfc5888">The Session Description Protocol (SDP) Grouping Framework</a>", RFC 5888, DOI 10.17487/RFC5888, June 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6236">[RFC6236]</b></td>
<td class="top">
<a>Johansson, I.</a> and <a>K. Jung</a>, "<a href="https://tools.ietf.org/html/rfc6236">Negotiation of Generic Image Attributes in the Session Description Protocol (SDP)</a>", RFC 6236, DOI 10.17487/RFC6236, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6347">[RFC6347]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="https://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6716">[RFC6716]</b></td>
<td class="top">
<a>Valin, JM.</a>, <a>Vos, K.</a> and <a>T. Terriberry</a>, "<a href="https://tools.ietf.org/html/rfc6716">Definition of the Opus Audio Codec</a>", RFC 6716, DOI 10.17487/RFC6716, September 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6904">[RFC6904]</b></td>
<td class="top">
<a>Lennox, J.</a>, "<a href="https://tools.ietf.org/html/rfc6904">Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP)</a>", RFC 6904, DOI 10.17487/RFC6904, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7160">[RFC7160]</b></td>
<td class="top">
<a>Petit-Huguenin, M.</a> and <a>G. Zorn</a>, "<a href="https://tools.ietf.org/html/rfc7160">Support for Multiple Clock Rates in an RTP Session</a>", RFC 7160, DOI 10.17487/RFC7160, April 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7587">[RFC7587]</b></td>
<td class="top">
<a>Spittka, J.</a>, <a>Vos, K.</a> and <a>JM. Valin</a>, "<a href="https://tools.ietf.org/html/rfc7587">RTP Payload Format for the Opus Speech and Audio Codec</a>", RFC 7587, DOI 10.17487/RFC7587, June 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7742">[RFC7742]</b></td>
<td class="top">
<a>Roach, A.</a>, "<a href="https://tools.ietf.org/html/rfc7742">WebRTC Video Processing and Codec Requirements</a>", RFC 7742, DOI 10.17487/RFC7742, March 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7850">[RFC7850]</b></td>
<td class="top">
<a>Nandakumar, S.</a>, "<a href="https://tools.ietf.org/html/rfc7850">Registering Values of the SDP 'proto' Field for Transporting RTP Media over TCP under Various RTP Profiles</a>", RFC 7850, DOI 10.17487/RFC7850, April 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7874">[RFC7874]</b></td>
<td class="top">
<a>Valin, JM.</a> and <a>C. Bran</a>, "<a href="https://tools.ietf.org/html/rfc7874">WebRTC Audio Codec and Processing Requirements</a>", RFC 7874, DOI 10.17487/RFC7874, May 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8108">[RFC8108]</b></td>
<td class="top">
<a>Lennox, J.</a>, <a>Westerlund, M.</a>, <a>Wu, Q.</a> and <a>C. Perkins</a>, "<a href="https://tools.ietf.org/html/rfc8108">Sending Multiple RTP Streams in a Single RTP Session</a>", RFC 8108, DOI 10.17487/RFC8108, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8122">[RFC8122]</b></td>
<td class="top">
<a>Lennox, J.</a> and <a>C. Holmberg</a>, "<a href="https://tools.ietf.org/html/rfc8122">Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)</a>", RFC 8122, DOI 10.17487/RFC8122, March 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8445">[RFC8445]</b></td>
<td class="top">
<a>Keranen, A.</a>, <a>Holmberg, C.</a> and <a>J. Rosenberg</a>, "<a href="https://tools.ietf.org/html/rfc8445">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</a>", RFC 8445, DOI 10.17487/RFC8445, July 2018.</td>
</tr>
</tbody></table>
<h2 id="rfc.references.2">
<a href="#rfc.references.2">11.2.</a> Informative References</h2>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-mmusic-trickle-ice-sip">[I-D.ietf-mmusic-trickle-ice-sip]</b></td>
<td class="top">
<a>Ivov, E.</a>, <a>Stach, T.</a>, <a>Marocco, E.</a> and <a>C. Holmberg</a>, "<a href="https://tools.ietf.org/html/draft-ietf-mmusic-trickle-ice-sip-18">A Session Initiation Protocol (SIP) Usage for Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (Trickle ICE)</a>", Internet-Draft draft-ietf-mmusic-trickle-ice-sip-18, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-ip-handling">[I-D.ietf-rtcweb-ip-handling]</b></td>
<td class="top">
<a>Uberti, J.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-ip-handling-11">WebRTC IP Address Handling Requirements</a>", Internet-Draft draft-ietf-rtcweb-ip-handling-11, November 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-rtcweb-sdp">[I-D.ietf-rtcweb-sdp]</b></td>
<td class="top">
<a>Nandakumar, S.</a> and <a>C. Jennings</a>, "<a href="https://tools.ietf.org/html/draft-ietf-rtcweb-sdp-11">Annotated Example SDP for WebRTC</a>", Internet-Draft draft-ietf-rtcweb-sdp-11, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3389">[RFC3389]</b></td>
<td class="top">
<a>Zopf, R.</a>, "<a href="https://tools.ietf.org/html/rfc3389">Real-time Transport Protocol (RTP) Payload for Comfort Noise (CN)</a>", RFC 3389, DOI 10.17487/RFC3389, September 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3556">[RFC3556]</b></td>
<td class="top">
<a>Casner, S.</a>, "<a href="https://tools.ietf.org/html/rfc3556">Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth</a>", RFC 3556, DOI 10.17487/RFC3556, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3960">[RFC3960]</b></td>
<td class="top">
<a>Camarillo, G.</a> and <a>H. Schulzrinne</a>, "<a href="https://tools.ietf.org/html/rfc3960">Early Media and Ringing Tone Generation in the Session Initiation Protocol (SIP)</a>", RFC 3960, DOI 10.17487/RFC3960, December 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4568">[RFC4568]</b></td>
<td class="top">
<a>Andreasen, F.</a>, <a>Baugher, M.</a> and <a>D. Wing</a>, "<a href="https://tools.ietf.org/html/rfc4568">Session Description Protocol (SDP) Security Descriptions for Media Streams</a>", RFC 4568, DOI 10.17487/RFC4568, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4588">[RFC4588]</b></td>
<td class="top">
<a>Rey, J.</a>, <a>Leon, D.</a>, <a>Miyazaki, A.</a>, <a>Varsa, V.</a> and <a>R. Hakenberg</a>, "<a href="https://tools.ietf.org/html/rfc4588">RTP Retransmission Payload Format</a>", RFC 4588, DOI 10.17487/RFC4588, July 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4733">[RFC4733]</b></td>
<td class="top">
<a>Schulzrinne, H.</a> and <a>T. Taylor</a>, "<a href="https://tools.ietf.org/html/rfc4733">RTP Payload for DTMF Digits, Telephony Tones, and Telephony Signals</a>", RFC 4733, DOI 10.17487/RFC4733, December 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5245">[RFC5245]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, "<a href="https://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, DOI 10.17487/RFC5245, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5506">[RFC5506]</b></td>
<td class="top">
<a>Johansson, I.</a> and <a>M. Westerlund</a>, "<a href="https://tools.ietf.org/html/rfc5506">Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences</a>", RFC 5506, DOI 10.17487/RFC5506, April 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5576">[RFC5576]</b></td>
<td class="top">
<a>Lennox, J.</a>, <a>Ott, J.</a> and <a>T. Schierl</a>, "<a href="https://tools.ietf.org/html/rfc5576">Source-Specific Media Attributes in the Session Description Protocol (SDP)</a>", RFC 5576, DOI 10.17487/RFC5576, June 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5763">[RFC5763]</b></td>
<td class="top">
<a>Fischl, J.</a>, <a>Tschofenig, H.</a> and <a>E. Rescorla</a>, "<a href="https://tools.ietf.org/html/rfc5763">Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)</a>", RFC 5763, DOI 10.17487/RFC5763, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5764">[RFC5764]</b></td>
<td class="top">
<a>McGrew, D.</a> and <a>E. Rescorla</a>, "<a href="https://tools.ietf.org/html/rfc5764">Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</a>", RFC 5764, DOI 10.17487/RFC5764, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6464">[RFC6464]</b></td>
<td class="top">
<a>Lennox, J.</a>, <a>Ivov, E.</a> and <a>E. Marocco</a>, "<a href="https://tools.ietf.org/html/rfc6464">A Real-time Transport Protocol (RTP) Header Extension for Client-to-Mixer Audio Level Indication</a>", RFC 6464, DOI 10.17487/RFC6464, December 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6544">[RFC6544]</b></td>
<td class="top">
<a>Rosenberg, J.</a>, <a>Keranen, A.</a>, <a>Lowekamp, B.</a> and <a>A. Roach</a>, "<a href="https://tools.ietf.org/html/rfc6544">TCP Candidates with Interactive Connectivity Establishment (ICE)</a>", RFC 6544, DOI 10.17487/RFC6544, March 2012.</td>
</tr>
<tr>
<td class="reference"><b id="TS26.114">[TS26.114]</b></td>
<td class="top">
<a>3GPP TS 26.114 V12.8.0</a>, "<a href="http://www.3gpp.org/DynaReport/26114.htm">3rd Generation Partnership Project; Technical Specification Group Services and System Aspects; IP Multimedia Subsystem (IMS); Multimedia Telephony; Media handling and interaction (Release 12)</a>", December 2014.</td>
</tr>
<tr>
<td class="reference"><b id="W3C.webrtc">[W3C.webrtc]</b></td>
<td class="top">
<a title="Ericsson">Bergkvist, A.</a>, <a>Burnett, D.</a>, <a title="Cisco">Jennings, C.</a>, <a title="Mozilla">Narayanan, A.</a>, <a title="Microsoft Corporation">Aboba, B.</a> and <a title="Google">T. Brandstetter</a>, "<a href="https://www.w3.org/TR/2017/WD-webrtc-20170515/">WebRTC 1.0: Real-time Communication Between Browsers</a>", World Wide Web Consortium WD WD-webrtc-20170515, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#sec.appendix-a" id="sec.appendix-a">Appendix A</a>
</h1>
<p id="rfc.section.A.p.1">For the syntax validation performed in <a href="#sec.parsing-a-desc" class="xref">Section 5.8</a>, the following list of ABNF definitions is used:</p>
<div id="rfc.table.1"></div>
<div id="sdp-abnf"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>SDP ABNF References</caption>
<thead><tr>
<th class="left">Attribute</th>
<th class="left">Reference</th>
</tr></thead>
<tbody>
<tr>
<td class="left">ptime</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">maxptime</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">rtpmap</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">recvonly</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">sendrecv</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">sendonly</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">inactive</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">framerate</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">fmtp</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">quality</td>
<td class="left">
<a href="#RFC4566" class="xref">[RFC4566]</a> Section 9</td>
</tr>
<tr>
<td class="left">rtcp</td>
<td class="left">
<a href="#RFC3605" class="xref">[RFC3605]</a> Section 2.1</td>
</tr>
<tr>
<td class="left">setup</td>
<td class="left">
<a href="#RFC4145" class="xref">[RFC4145]</a> Sections 3, 4, and 5</td>
</tr>
<tr>
<td class="left">connection</td>
<td class="left">
<a href="#RFC4145" class="xref">[RFC4145]</a> Sections 3, 4, and 5</td>
</tr>
<tr>
<td class="left">fingerprint</td>
<td class="left">
<a href="#RFC8122" class="xref">[RFC8122]</a> Section 5</td>
</tr>
<tr>
<td class="left">rtcp-fb</td>
<td class="left">
<a href="#RFC4585" class="xref">[RFC4585]</a> Section 4.2</td>
</tr>
<tr>
<td class="left">extmap</td>
<td class="left">
<a href="#RFC5285" class="xref">[RFC5285]</a> Section 7</td>
</tr>
<tr>
<td class="left">mid</td>
<td class="left">
<a href="#RFC5888" class="xref">[RFC5888]</a> Sections 4 and 5</td>
</tr>
<tr>
<td class="left">group</td>
<td class="left">
<a href="#RFC5888" class="xref">[RFC5888]</a> Sections 4 and 5</td>
</tr>
<tr>
<td class="left">imageattr</td>
<td class="left">
<a href="#RFC6236" class="xref">[RFC6236]</a> Section 3.1</td>
</tr>
<tr>
<td class="left">extmap (encrypt option)</td>
<td class="left">
<a href="#RFC6904" class="xref">[RFC6904]</a> Section 4</td>
</tr>
<tr>
<td class="left">candidate</td>
<td class="left">
<a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a> Section 4.1</td>
</tr>
<tr>
<td class="left">remote-candidates</td>
<td class="left">
<a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a> Section 4.2</td>
</tr>
<tr>
<td class="left">ice-lite</td>
<td class="left">
<a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a> Section 4.3</td>
</tr>
<tr>
<td class="left">ice-ufrag</td>
<td class="left">
<a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a> Section 4.4</td>
</tr>
<tr>
<td class="left">ice-pwd</td>
<td class="left">
<a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a> Section 4.4</td>
</tr>
<tr>
<td class="left">ice-options</td>
<td class="left">
<a href="#I-D.ietf-mmusic-ice-sip-sdp" class="xref">[I-D.ietf-mmusic-ice-sip-sdp]</a> Section 4.6</td>
</tr>
<tr>
<td class="left">msid</td>
<td class="left">
<a href="#I-D.ietf-mmusic-msid" class="xref">[I-D.ietf-mmusic-msid]</a> Section 2</td>
</tr>
<tr>
<td class="left">rid</td>
<td class="left">
<a href="#I-D.ietf-mmusic-rid" class="xref">[I-D.ietf-mmusic-rid]</a> Section 10</td>
</tr>
<tr>
<td class="left">simulcast</td>
<td class="left">
<a href="#I-D.ietf-mmusic-sdp-simulcast" class="xref">[I-D.ietf-mmusic-sdp-simulcast]</a> Section 6.1</td>
</tr>
<tr>
<td class="left">tls-id</td>
<td class="left">
<a href="#I-D.ietf-mmusic-dtls-sdp" class="xref">[I-D.ietf-mmusic-dtls-sdp]</a> Section 4</td>
</tr>
</tbody>
</table>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#sec.change-log" id="sec.change-log">Change log</a>
</h1>
<p id="rfc.section.B.p.1">Note to RFC Editor: Please remove this section before publication.</p>
<p id="rfc.section.B.p.2">Changes in draft-26:</p>
<p></p>

<ul><li>Update guidance on generation of the m= proto value to be consistent with ice-sip-sdp.</li></ul>

<p> </p>
<p id="rfc.section.B.p.4">Changes in draft-25:</p>
<p></p>

<ul>
<li>Remove MSID track ID from offers and answers.</li>
<li>Add note about rejecting all m= sections in a BUNDLE group.</li>
<li>Update ICE references to RFC 8445 and mention ice2.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.6">Changes in draft-24:</p>
<p></p>

<ul>
<li>Clarify that rounding is permitted when trying to maintain aspect ratio.</li>
<li>Update tls-id handling to match what is specified in dtls-sdp.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.8">Changes in draft-23:</p>
<p></p>

<ul>
<li>Clarify rollback handling, and treat it similarly to other setLocal/setRemote usages.</li>
<li>Adopt a first-fit policy for handling multiple remote a=imageattr attributes.</li>
<li>Clarify that a session description with zero m= sections is legal.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.10">Changes in draft-22:</p>
<p></p>

<ul>
<li>Clarify currentDirection versus direction.</li>
<li>Correct session-id text so that it aligns with RFC 3264.</li>
<li>Clarify that generated ICE candidate objects must have all four fields.</li>
<li>Make rollback work from any state besides stable and regardless of whether setLocalDescription or setRemoteDescription is used.</li>
<li>Allow modifying SDP before sending or after receiving either offers or answers (previously this was forbidden for answers).</li>
<li>Provide rationale for several design choices.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.12">Changes in draft-21:</p>
<p></p>

<ul>
<li>Change dtls-id to tls-id to match MMUSIC draft.</li>
<li>Replace regular expression for proto field with a list and clarify that the answer must exactly match the offer.</li>
<li>Remove text about how to error check on setLocal because local descriptions cannot be changed.</li>
<li>Rework silence suppression support to always require that both sides agree to silence suppression or none is used.</li>
<li>Remove instructions to parse "a=ssrc-group".</li>
<li>Allow the addition of new codecs in answers and in subsequent offers.</li>
<li>Clarify imageattr processing. Replace use of [x=0,y=0] with direction indicators.</li>
<li>Document when early media can occur.</li>
<li>Fix ICE default port handling when bundle-only is used.</li>
<li>Forbid duplicating IDENTICAL/TRANSPORT attributes when you are bundling.</li>
<li>Clarify the number of components to gather when bundle is involved.</li>
<li>Explicitly state that PTs and SSRCs are to be used for demuxing.</li>
<li>Update guidance on "a=setup" line. This should now match the MMUSIC draft.</li>
<li>Update guidance on certificate/digest matching to conform to RFC8122.</li>
<li>Update examples.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.14">Changes in draft-20:</p>
<p></p>

<ul><li>Remove Appendix-B.</li></ul>

<p> </p>
<p id="rfc.section.B.p.16">Changes in draft-19:</p>
<p></p>

<ul>
<li>Examples are now machine-generated for correctness, and use IETF-approved example IP addresses.</li>
<li>Add early transport warmup example, and add missing attributes to existing examples.</li>
<li>Only send "a=rtcp-mux-only" and "a=bundle-only" on new m= sections.</li>
<li>Update references.</li>
<li>Add coverage of a=identity.</li>
<li>Explain the lipsync group algorithm more thoroughly.</li>
<li>Remove unnecessary list of MTI specs.</li>
<li>Allow codecs which weren't offered to appear in answers and which weren't selected to appear in subsequent offers.</li>
<li>Codec preferences now are applied on both initial and subsequent offers and answers.</li>
<li>Clarify a=msid handling for recvonly m= sections.</li>
<li>Clarify behavior of attributes for bundle-only data channels.</li>
<li>Allow media attributes to appear in data m= sections when all the media m= sections are bundle-only.</li>
<li>Use consistent terminology for JSEP implementations.</li>
<li>Describe how to handle failed API calls.</li>
<li>Some cleanup on routing rules.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.18">Changes in draft-18:</p>
<p></p>

<ul>
<li>Update demux algorithm and move it to an appendix in preparation for merging it into BUNDLE.</li>
<li>Clarify why we can't handle an incoming offer to send simulcast.</li>
<li>Expand IceCandidate object text.</li>
<li>Further document use of ICE candidate pool.</li>
<li>Document removeTrack.</li>
<li>Update requirements to only accept the last generated offer/answer as an argument to setLocalDescription.</li>
<li>Allow round pixels.</li>
<li>Fix code around default timing when AVPF is not specified.</li>
<li>Clean up terminology around m= line and m=section.</li>
<li>Provide a more realistic example for minimum decoder capabilities.</li>
<li>Document behavior when rtcp-mux policy is require but rtcp-mux attribute not provided.</li>
<li>Expanded discussion of RtpSender and RtpReceiver.</li>
<li>Add RtpTransceiver.currentDirection and document setDirection.</li>
<li>Require imageattr x=0, y=0 to indicate that there are no valid resolutions.</li>
<li>Require a privacy-preserving MID/RID construction.</li>
<li>Require support for RFC 3556 bandwidth modifiers.</li>
<li>Update maxptime description.</li>
<li>Note that endpoints may encounter extra codecs in answers and subsequent offers from non-JSEP peers.</li>
<li>Update references.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.20">Changes in draft-17:</p>
<p></p>

<ul>
<li>Split createOffer and createAnswer sections to clearly indicate attributes which always appear and which only appear when not bundled into another m= section.</li>
<li>Add descriptions of RtpTransceiver methods.</li>
<li>Describe how to process RTCP feedback attributes.</li>
<li>Clarify transceiver directions and their interaction with 3264.</li>
<li>Describe setCodecPreferences.</li>
<li>Update RTP demux algorithm. Include RTCP.</li>
<li>Update requirements for when a=rtcp is included, limiting to cases where it is needed for backward compatibility.</li>
<li>Clarify SAR handling.</li>
<li>Updated addTrack matching algorithm.</li>
<li>Remove a=ssrc requirements.</li>
<li>Handle a=setup in reoffers.</li>
<li>Discuss how RTX/FEC should be handled.</li>
<li>Discuss how telephone-event should be handled.</li>
<li>Discuss how CN/DTX should be handled.</li>
<li>Add missing references to ABNF table.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.22">Changes in draft-16:</p>
<p></p>

<ul>
<li>Update addIceCandidate to indicate ICE generation and allow per-m= section end-of-candidates.</li>
<li>Update fingerprint handling to use draft-ietf-mmusic-4572-update.</li>
<li>Update text around SDP processing of RTP header extensions and payload formats.</li>
<li>Add sections on simulcast, addTransceiver, and createDataChannel.</li>
<li>Clarify text to ensure that the session ID is a positive 63 bit integer.</li>
<li>Clarify SDP processing for direction indication.</li>
<li>Describe SDP processing for rtcp-mux-only.</li>
<li>Specify how SDP session version in o= line.</li>
<li>Require that when doing an re-offer, the capabilities of the new session are mostly required to be a subset of the previously negotiated session.</li>
<li>Clarified ICE restart interaction with bundle-only.</li>
<li>Remove support for changing SDP before calling setLocalDescription.</li>
<li>Specify algorithm for demuxing RTP based on MID, PT, and SSRC.</li>
<li>Clarify rules for rejecting m= lines when bundle policy is balanced or max-bundle.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.24">Changes in draft-15:</p>
<p></p>

<ul>
<li>Clarify text around codecs offered in subsequent transactions to refer to what's been negotiated.</li>
<li>Rewrite LS handling text to indicate edge cases and that we're living with them.</li>
<li>Require that answerer reject m= lines when there are no codecs in common.</li>
<li>Enforce max-bundle on offer processing.</li>
<li>Fix TIAS formula to handle bits vs. kilobits.</li>
<li>Describe addTrack algorithm.</li>
<li>Clean up references.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.26">Changes in draft-14:</p>
<p></p>

<ul>
<li>Added discussion of RtpTransceivers + RtpSenders + RtpReceivers, and how they interact with createOffer/createAnswer.</li>
<li>Removed obsolete OfferToReceiveX options.</li>
<li>Explained how addIceCandidate can be used for end-of-candidates.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.28">Changes in draft-13:</p>
<p></p>

<ul>
<li>Clarified which SDP lines can be ignored.</li>
<li>Clarified how to handle various received attributes.</li>
<li>Revised how attributes should be generated for bundled m= lines.</li>
<li>Remove unused references.</li>
<li>Remove text advocating use of unilateral PTs.</li>
<li>Trigger an ICE restart even if the ICE candidate policy is being made more strict.</li>
<li>Remove the 'public' ICE candidate policy.</li>
<li>Move open issues into GitHub issues.</li>
<li>Split local/remote description accessors into current/pending.</li>
<li>Clarify a=imageattr handling.</li>
<li>Add more detail on VoiceActivityDetection handling.</li>
<li>Reference draft-shieh-rtcweb-ip-handling.</li>
<li>Make it clear when an ICE restart should occur.</li>
<li>Resolve changes needed in references.</li>
<li>Remove MSID semantics.</li>
<li>ice-options are now at session level.</li>
<li>Default RTCP mux policy is now 'require'.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.30">Changes in draft-12:</p>
<p></p>

<ul>
<li>Filled in sections on applying local and remote descriptions.</li>
<li>Discussed downscaling and upscaling to fulfill imageattr requirements.</li>
<li>Updated what SDP can be modified by the application.</li>
<li>Updated to latest datachannel SDP.</li>
<li>Allowed multiple fingerprint lines.</li>
<li>Switched back to IPv4 for dummy candidates.</li>
<li>Added additional clarity on ICE default candidates.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.32">Changes in draft-11:</p>
<p></p>

<ul>
<li>Clarified handling of RTP CNAMEs.</li>
<li>Updated what SDP lines should be processed or ignored.</li>
<li>Specified how a=imageattr should be used.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.34">Changes in draft-10:</p>
<p></p>

<ul>
<li>Described video size negotiation with imageattr.</li>
<li>Clarified rejection of sections that do not have mux-only.</li>
<li>Add handling of LS groups</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.36">Changes in draft-09:</p>
<p></p>

<ul>
<li>Don't return null for {local,remote}Description after close().</li>
<li>Changed TCP/TLS to UDP/DTLS in RTP profile names.</li>
<li>Separate out bundle and mux policy.</li>
<li>Added specific references to FEC mechanisms.</li>
<li>Added canTrickle mechanism.</li>
<li>Added section on subsequent answers and, answer options.</li>
<li>Added text defining set{Local,Remote}Description behavior.</li>
</ul>

<p> </p>
<p id="rfc.section.B.p.38">Changes in draft-08: </p>

<ul>
<li>Added new example section and removed old examples in appendix.</li>
<li>Fixed &lt;proto&gt; field handling.</li>
<li>Added text describing a=rtcp attribute.</li>
<li>Reworked handling of OfferToReceiveAudio and OfferToReceiveVideo per discussion at IETF 90.</li>
<li>Reworked trickle ICE handling and its impact on m= and c= lines per discussion at interim.</li>
<li>Added max-bundle-and-rtcp-mux policy.</li>
<li>Added description of maxptime handling.</li>
<li>Updated ICE candidate pool default to 0.</li>
<li>Resolved open issues around AppID/receiver-ID.</li>
<li>Reworked and expanded how changes to the ICE configuration are handled.</li>
<li>Some reference updates.</li>
<li>Editorial clarification.</li>
</ul>
<p id="rfc.section.B.p.39">Changes in draft-07: </p>

<ul>
<li>Expanded discussion of VAD and Opus DTX.</li>
<li>Added a security considerations section.</li>
<li>Rewrote the section on modifying SDP to require implementations to clearly indicate whether any given modification is allowed.</li>
<li>Clarified impact of IceRestart on CreateOffer in local-offer state.</li>
<li>Guidance on whether attributes should be defined at the media level or the session level.</li>
<li>Renamed "default" bundle policy to "balanced".</li>
<li>Removed default ICE candidate pool size and clarify how it works.</li>
<li>Defined a canonical order for assignment of MSTs to m= lines.</li>
<li>Removed discussion of rehydration.</li>
<li>Added Eric Rescorla as a draft editor.</li>
<li>Cleaned up references.</li>
<li>Editorial cleanup</li>
</ul>
<p id="rfc.section.B.p.40">Changes in draft-06: </p>

<ul>
<li>Reworked handling of m= line recycling.</li>
<li>Added handling of BUNDLE and bundle-only.</li>
<li>Clarified handling of rollback.</li>
<li>Added text describing the ICE Candidate Pool and its behavior.</li>
<li>Allowed OfferToReceiveX to create multiple recvonly m= sections.</li>
</ul>
<p id="rfc.section.B.p.41">Changes in draft-05: </p>

<ul>
<li>Fixed several issues identified in the createOffer/Answer sections during document review.</li>
<li>Updated references.</li>
</ul>
<p id="rfc.section.B.p.42">Changes in draft-04: </p>

<ul>
<li>Filled in sections on createOffer and createAnswer.</li>
<li>Added SDP examples.</li>
<li>Fixed references.</li>
</ul>
<p id="rfc.section.B.p.43">Changes in draft-03: </p>

<ul><li>Added text describing relationship to W3C specification</li></ul>
<p id="rfc.section.B.p.44">Changes in draft-02: </p>

<ul>
<li>Converted from nroff</li>
<li>Removed comparisons to old approaches abandoned by the working group</li>
<li>Removed stuff that has moved to W3C specification</li>
<li>Align SDP handling with W3C draft</li>
<li>Clarified section on forking.</li>
</ul>
<p id="rfc.section.B.p.45">Changes in draft-01: </p>

<ul>
<li>Added diagrams for architecture and state machine.</li>
<li>Added sections on forking and rehydration.</li>
<li>Clarified meaning of "pranswer" and "answer".</li>
<li>Reworked how ICE restarts and media directions are controlled.</li>
<li>Added list of parameters that can be changed in a description.</li>
<li>Updated suggested API and examples to match latest thinking.</li>
<li>Suggested API and examples have been moved to an appendix.</li>
</ul>
<p id="rfc.section.B.p.46">Changes in draft -00: </p>

<ul><li>Migrated from draft-uberti-rtcweb-jsep-02.</li></ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Justin Uberti</span> 
	  <span class="n hidden">
		<span class="family-name">Uberti</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span class="vcardline">747 6th St S</span>

	  <span class="vcardline">
		<span class="locality">Kirkland</span>,  
		<span class="region">WA</span> 
		<span class="code">98033</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:justin@uberti.name">justin@uberti.name</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Cullen Jennings</span> 
	  <span class="n hidden">
		<span class="family-name">Jennings</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco</span>
	<span class="adr">
	  <span class="vcardline">400 3rd Avenue SW</span>

	  <span class="vcardline">
		<span class="locality">Calgary</span>,  
		<span class="region">AB</span> 
		<span class="code">T2P 4H2</span>
	  </span>
	  <span class="country-name vcardline">Canada</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:fluffy@iii.ca">fluffy@iii.ca</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">Mozilla</span>
	<span class="adr">
	  <span class="vcardline">331 Evelyn Ave</span>

	  <span class="vcardline">
		<span class="locality">Mountain View</span>,  
		<span class="region">CA</span> 
		<span class="code">94041</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/rtcweb-wg/jsep">Fork me on GitHub</a></div></div>
</body>
</html>
